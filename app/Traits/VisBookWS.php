<?php

/**
 *
 *
 *
 * Generated by <a href="http://enunciate.webcohesion.com">Enunciate</a>.
 *
 */
namespace App\Traits;

/**
 * (no documentation provided)
 */
class Attribute
{

    /**
     * unique identifier for the attribute.
     *
     * @var integer
     */
    private $id;

    /**
     * attributeGroup object, refer to which group this attribute is related to
     *
     * @var \App\Traits\AttributeGroup
     */
    private $group;

    /**
     * attribute value
     *
     * @var string
     */
    private $value;

    /**
     * set to language code if value is translated. Else null or empty
     *
     * @var string
     */
    private $language;

    /**
     * contains which company_id this attribute belongs to
     *
     * @var integer
     */
    private $company_id;

    /**
     * (optional) product_id this attribute belongs to
     *
     * @var integer
     */
    private $product_id;

    /**
     * (optional) unit_id this attribute belongs to
     *
     * @var integer
     */
    private $unit_id;

    /**
     * If the attribute is an image, provides image_info for the image
     *
     * @var \App\Traits\AttributeImageInfo
     */
    private $image_info;

    /**
     * Constructs a Attribute from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * unique identifier for the attribute.
     *
     * @return integer
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * unique identifier for the attribute.
     *
     * @param integer $id
     */
    public function setId($id)
    {
        $this->id = $id;
    }
    /**
     * attributeGroup object, refer to which group this attribute is related to
     *
     * @return \App\Traits\AttributeGroup
     */
    public function getGroup()
    {
        return $this->group;
    }

    /**
     * attributeGroup object, refer to which group this attribute is related to
     *
     * @param \App\Traits\AttributeGroup $group
     */
    public function setGroup($group)
    {
        $this->group = $group;
    }
    /**
     * attribute value
     *
     * @return string
     */
    public function getValue()
    {
        return $this->value;
    }

    /**
     * attribute value
     *
     * @param string $value
     */
    public function setValue($value)
    {
        $this->value = $value;
    }
    /**
     * set to language code if value is translated. Else null or empty
     *
     * @return string
     */
    public function getLanguage()
    {
        return $this->language;
    }

    /**
     * set to language code if value is translated. Else null or empty
     *
     * @param string $language
     */
    public function setLanguage($language)
    {
        $this->language = $language;
    }
    /**
     * contains which company_id this attribute belongs to
     *
     * @return integer
     */
    public function getCompany_id()
    {
        return $this->company_id;
    }

    /**
     * contains which company_id this attribute belongs to
     *
     * @param integer $company_id
     */
    public function setCompany_id($company_id)
    {
        $this->company_id = $company_id;
    }
    /**
     * (optional) product_id this attribute belongs to
     *
     * @return integer
     */
    public function getProduct_id()
    {
        return $this->product_id;
    }

    /**
     * (optional) product_id this attribute belongs to
     *
     * @param integer $product_id
     */
    public function setProduct_id($product_id)
    {
        $this->product_id = $product_id;
    }
    /**
     * (optional) unit_id this attribute belongs to
     *
     * @return integer
     */
    public function getUnit_id()
    {
        return $this->unit_id;
    }

    /**
     * (optional) unit_id this attribute belongs to
     *
     * @param integer $unit_id
     */
    public function setUnit_id($unit_id)
    {
        $this->unit_id = $unit_id;
    }
    /**
     * If the attribute is an image, provides image_info for the image
     *
     * @return \App\Traits\AttributeImageInfo
     */
    public function getImage_info()
    {
        return $this->image_info;
    }

    /**
     * If the attribute is an image, provides image_info for the image
     *
     * @param \App\Traits\AttributeImageInfo $image_info
     */
    public function setImage_info($image_info)
    {
        $this->image_info = $image_info;
    }

    /**
     * Initializes this Attribute from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of Attribute from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'group') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\AttributeGroup($xml);
            $this->group = $child;
            $happened = true;
        }
        else if (($xml->localName == 'value') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->value = $child;
            $happened = true;
        }
        else if (($xml->localName == 'language') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->language = $child;
            $happened = true;
        }
        else if (($xml->localName == 'company_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->company_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'product_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->product_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'unit_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->unit_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'image_info') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\AttributeImageInfo($xml);
            $this->image_info = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of Attribute from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this Attribute to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->id) {
            $writer->startElementNs(null, 'id', null);
            $writer->text($this->id);
            $writer->endElement();
        }
        if ($this->group) {
            $writer->startElementNs(null, 'group', null);
            $this->group->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->value) {
            $writer->startElementNs(null, 'value', null);
            $writer->text($this->value);
            $writer->endElement();
        }
        if ($this->language) {
            $writer->startElementNs(null, 'language', null);
            $writer->text($this->language);
            $writer->endElement();
        }
        if ($this->company_id) {
            $writer->startElementNs(null, 'company_id', null);
            $writer->text($this->company_id);
            $writer->endElement();
        }
        if ($this->product_id) {
            $writer->startElementNs(null, 'product_id', null);
            $writer->text($this->product_id);
            $writer->endElement();
        }
        if ($this->unit_id) {
            $writer->startElementNs(null, 'unit_id', null);
            $writer->text($this->unit_id);
            $writer->endElement();
        }
        if ($this->image_info) {
            $writer->startElementNs(null, 'image_info', null);
            $this->image_info->writeXmlContents($writer);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class AttributeGroup
{

    /**
     * globally unique identification (also unique across company_id)
     *
     * @var integer
     */
    private $group_id;

    /**
     * company identification id if related specially to a company (local)
     *
     * @var integer
     */
    private $company_id;

    /**
     * descriptive name
     *
     * @var string
     */
    private $name;

    /**
     * attributeType (boolean, numeric etc), see description of attributeType enum
     *
     * @var string
     */
    private $type;

    /**
     * set to 2-char language code if descriptive name is translated, else null or empty
     *
     * @var string
     */
    private $language;

    /**
     * if the attributeType is TEXTGROUP, this will contain a list of textGroupItem with the possible values.
     *
     * @var \App\Traits\TextGroupItem[]
     */
    private $text_group_items;

    /**
     * Constructs a AttributeGroup from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * globally unique identification (also unique across company_id)
     *
     * @return integer
     */
    public function getGroup_id()
    {
        return $this->group_id;
    }

    /**
     * globally unique identification (also unique across company_id)
     *
     * @param integer $group_id
     */
    public function setGroup_id($group_id)
    {
        $this->group_id = $group_id;
    }
    /**
     * company identification id if related specially to a company (local)
     *
     * @return integer
     */
    public function getCompany_id()
    {
        return $this->company_id;
    }

    /**
     * company identification id if related specially to a company (local)
     *
     * @param integer $company_id
     */
    public function setCompany_id($company_id)
    {
        $this->company_id = $company_id;
    }
    /**
     * descriptive name
     *
     * @return string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * descriptive name
     *
     * @param string $name
     */
    public function setName($name)
    {
        $this->name = $name;
    }
    /**
     * attributeType (boolean, numeric etc), see description of attributeType enum
     *
     * @return string
     */
    public function getType()
    {
        return $this->type;
    }

    /**
     * attributeType (boolean, numeric etc), see description of attributeType enum
     *
     * @param string $type
     */
    public function setType($type)
    {
        $this->type = $type;
    }
    /**
     * set to 2-char language code if descriptive name is translated, else null or empty
     *
     * @return string
     */
    public function getLanguage()
    {
        return $this->language;
    }

    /**
     * set to 2-char language code if descriptive name is translated, else null or empty
     *
     * @param string $language
     */
    public function setLanguage($language)
    {
        $this->language = $language;
    }
    /**
     * if the attributeType is TEXTGROUP, this will contain a list of textGroupItem with the possible values.
     *
     * @return \App\Traits\TextGroupItem[]
     */
    public function getText_group_items()
    {
        return $this->text_group_items;
    }

    /**
     * if the attributeType is TEXTGROUP, this will contain a list of textGroupItem with the possible values.
     *
     * @param \App\Traits\TextGroupItem[] $text_group_items
     */
    public function setText_group_items($text_group_items)
    {
        $this->text_group_items = $text_group_items;
    }

    /**
     * Initializes this AttributeGroup from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of AttributeGroup from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'group_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->group_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'company_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->company_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'name') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->name = $child;
            $happened = true;
        }
        else if (($xml->localName == 'type') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->type = $child;
            $happened = true;
        }
        else if (($xml->localName == 'language') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->language = $child;
            $happened = true;
        }
        else if (($xml->localName == 'text_group_items') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\TextGroupItem($xml);
            if (!isset($this->text_group_items)) {
                $this->text_group_items = array();
            }
            array_push($this->text_group_items, $child);
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of AttributeGroup from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this AttributeGroup to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->group_id) {
            $writer->startElementNs(null, 'group_id', null);
            $writer->text($this->group_id);
            $writer->endElement();
        }
        if ($this->company_id) {
            $writer->startElementNs(null, 'company_id', null);
            $writer->text($this->company_id);
            $writer->endElement();
        }
        if ($this->name) {
            $writer->startElementNs(null, 'name', null);
            $writer->text($this->name);
            $writer->endElement();
        }
        if ($this->type) {
            $writer->startElementNs(null, 'type', null);
            $writer->text($this->type);
            $writer->endElement();
        }
        if ($this->language) {
            $writer->startElementNs(null, 'language', null);
            $writer->text($this->language);
            $writer->endElement();
        }
        if ($this->text_group_items) {
            foreach ($this->text_group_items as $i => $x) {
                $writer->startElementNs(null, 'text_group_items', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class AttributeImageInfo
{

    /**
     * unique image info id
     *
     * @var integer
     */
    private $id;

    /**
     * refers to an image info id that is an master for this image
     *
     * @var integer
     */
    private $masterId;

    /**
     * enum of thumbnailType that specifies if this image is an thumbnail, and which type
     *
     * @var string
     */
    private $thumbnailType;

    /**
     * Constructs a AttributeImageInfo from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * unique image info id
     *
     * @return integer
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * unique image info id
     *
     * @param integer $id
     */
    public function setId($id)
    {
        $this->id = $id;
    }
    /**
     * refers to an image info id that is an master for this image
     *
     * @return integer
     */
    public function getMasterId()
    {
        return $this->masterId;
    }

    /**
     * refers to an image info id that is an master for this image
     *
     * @param integer $masterId
     */
    public function setMasterId($masterId)
    {
        $this->masterId = $masterId;
    }
    /**
     * enum of thumbnailType that specifies if this image is an thumbnail, and which type
     *
     * @return string
     */
    public function getThumbnailType()
    {
        return $this->thumbnailType;
    }

    /**
     * enum of thumbnailType that specifies if this image is an thumbnail, and which type
     *
     * @param string $thumbnailType
     */
    public function setThumbnailType($thumbnailType)
    {
        $this->thumbnailType = $thumbnailType;
    }

    /**
     * Initializes this AttributeImageInfo from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of AttributeImageInfo from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'masterId') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->masterId = $child;
            $happened = true;
        }
        else if (($xml->localName == 'thumbnailType') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->thumbnailType = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of AttributeImageInfo from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this AttributeImageInfo to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->id) {
            $writer->startElementNs(null, 'id', null);
            $writer->text($this->id);
            $writer->endElement();
        }
        if ($this->masterId) {
            $writer->startElementNs(null, 'masterId', null);
            $writer->text($this->masterId);
            $writer->endElement();
        }
        if ($this->thumbnailType) {
            $writer->startElementNs(null, 'thumbnailType', null);
            $writer->text($this->thumbnailType);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class AttributeQuery
{

    /**
     * attributeGroup object to do the query search in
     *
     * @var \App\Traits\AttributeGroup
     */
    private $group;

    /**
     * condition operator (equals, less_than etc...)
     *
     * @var string
     */
    private $operator;

    /**
     * condition value
     *
     * @var string
     */
    private $value;

    /**
     * optional list of attributeQuery objects &lt;b&gt;required&lt;/b&gt; to match (&lt;i&gt;AND&lt;/i&gt; type query)
     *
     * @var \App\Traits\AttributeQuery[]
     */
    private $require_match;

    /**
     * optional boolean flag, set to true if querying for products, and the
     * products should be included if the attribute is set globally company vide.&lt;br&gt;
     * F.ex. if the company has set distance_airport_code = OSL, using find_products with a query to match that attribute
     * and the product_inherit_company is set to true, all products in that company will match,
     * regardless if the product has set the attribute or not. &lt;br&gt;
     * If the query searches for TRD, the company attribute is set to OSL, but one of the products has the attribute set to TRD, only that product
     * will be returned. &lt;br&gt;
     * In most cases, &quot;true&quot; should be used.
     *
     * @var boolean
     */
    private $product_inherit_company;

    /**
     * Constructs a AttributeQuery from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * attributeGroup object to do the query search in
     *
     * @return \App\Traits\AttributeGroup
     */
    public function getGroup()
    {
        return $this->group;
    }

    /**
     * attributeGroup object to do the query search in
     *
     * @param \App\Traits\AttributeGroup $group
     */
    public function setGroup($group)
    {
        $this->group = $group;
    }
    /**
     * condition operator (equals, less_than etc...)
     *
     * @return string
     */
    public function getOperator()
    {
        return $this->operator;
    }

    /**
     * condition operator (equals, less_than etc...)
     *
     * @param string $operator
     */
    public function setOperator($operator)
    {
        $this->operator = $operator;
    }
    /**
     * condition value
     *
     * @return string
     */
    public function getValue()
    {
        return $this->value;
    }

    /**
     * condition value
     *
     * @param string $value
     */
    public function setValue($value)
    {
        $this->value = $value;
    }
    /**
     * optional list of attributeQuery objects &lt;b&gt;required&lt;/b&gt; to match (&lt;i&gt;AND&lt;/i&gt; type query)
     *
     * @return \App\Traits\AttributeQuery[]
     */
    public function getRequire_match()
    {
        return $this->require_match;
    }

    /**
     * optional list of attributeQuery objects &lt;b&gt;required&lt;/b&gt; to match (&lt;i&gt;AND&lt;/i&gt; type query)
     *
     * @param \App\Traits\AttributeQuery[] $require_match
     */
    public function setRequire_match($require_match)
    {
        $this->require_match = $require_match;
    }
    /**
     * optional boolean flag, set to true if querying for products, and the
       * products should be included if the attribute is set globally company vide.&lt;br&gt;
       * F.ex. if the company has set distance_airport_code = OSL, using find_products with a query to match that attribute
       * and the product_inherit_company is set to true, all products in that company will match,
       * regardless if the product has set the attribute or not. &lt;br&gt;
       * If the query searches for TRD, the company attribute is set to OSL, but one of the products has the attribute set to TRD, only that product
       * will be returned. &lt;br&gt;
       * In most cases, &quot;true&quot; should be used.
     *
     * @return boolean
     */
    public function getProduct_inherit_company()
    {
        return $this->product_inherit_company;
    }

    /**
     * optional boolean flag, set to true if querying for products, and the
       * products should be included if the attribute is set globally company vide.&lt;br&gt;
       * F.ex. if the company has set distance_airport_code = OSL, using find_products with a query to match that attribute
       * and the product_inherit_company is set to true, all products in that company will match,
       * regardless if the product has set the attribute or not. &lt;br&gt;
       * If the query searches for TRD, the company attribute is set to OSL, but one of the products has the attribute set to TRD, only that product
       * will be returned. &lt;br&gt;
       * In most cases, &quot;true&quot; should be used.
     *
     * @param boolean $product_inherit_company
     */
    public function setProduct_inherit_company($product_inherit_company)
    {
        $this->product_inherit_company = $product_inherit_company;
    }

    /**
     * Initializes this AttributeQuery from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of AttributeQuery from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'group') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\AttributeGroup($xml);
            $this->group = $child;
            $happened = true;
        }
        else if (($xml->localName == 'operator') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->operator = $child;
            $happened = true;
        }
        else if (($xml->localName == 'value') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->value = $child;
            $happened = true;
        }
        else if (($xml->localName == 'require_match') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\AttributeQuery($xml);
            if (!isset($this->require_match)) {
                $this->require_match = array();
            }
            array_push($this->require_match, $child);
            $happened = true;
        }
        else if (($xml->localName == 'product_inherit_company') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->product_inherit_company = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of AttributeQuery from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this AttributeQuery to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->group) {
            $writer->startElementNs(null, 'group', null);
            $this->group->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->operator) {
            $writer->startElementNs(null, 'operator', null);
            $writer->text($this->operator);
            $writer->endElement();
        }
        if ($this->value) {
            $writer->startElementNs(null, 'value', null);
            $writer->text($this->value);
            $writer->endElement();
        }
        if ($this->require_match) {
            foreach ($this->require_match as $i => $x) {
                $writer->startElementNs(null, 'require_match', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->product_inherit_company) {
            $writer->startElementNs(null, 'product_inherit_company', null);
            $writer->text($this->product_inherit_company);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class TextGroupItem
{

    /**
     * Identification&lt;br&gt;
     * &lt;p&gt;&lt;i&gt;Note that this id should not be used as unique identificator for the item value in a textgroup, the
     * value field is the identificator of what the textgroup-type attribute has selected. f.ex. global
     * textGroupItem describing a value of “Hotel” in a textgroup choice of company type will possibly
     * have a different id when querying a local attribute list of a company, but the value “Hotel” will be
     * the same.&lt;/i&gt;&lt;/P&gt;
     *
     * @var integer
     */
    private $id;

    /**
     * set to language code if value has a translation, else null or empty
     *
     * @var string
     */
    private $language;

    /**
     * the item value. This is the value that the TEXTGROUP attribute object should set as its value
     *
     * @var string
     */
    private $value;

    /**
     * value text translated according to language, if possible.
     *
     * @var string
     */
    private $translated;

    /**
     * Constructs a TextGroupItem from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * Identification&lt;br&gt;
       * &lt;p&gt;&lt;i&gt;Note that this id should not be used as unique identificator for the item value in a textgroup, the
       * value field is the identificator of what the textgroup-type attribute has selected. f.ex. global
       * textGroupItem describing a value of “Hotel” in a textgroup choice of company type will possibly
       * have a different id when querying a local attribute list of a company, but the value “Hotel” will be
       * the same.&lt;/i&gt;&lt;/P&gt;
     *
     * @return integer
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * Identification&lt;br&gt;
       * &lt;p&gt;&lt;i&gt;Note that this id should not be used as unique identificator for the item value in a textgroup, the
       * value field is the identificator of what the textgroup-type attribute has selected. f.ex. global
       * textGroupItem describing a value of “Hotel” in a textgroup choice of company type will possibly
       * have a different id when querying a local attribute list of a company, but the value “Hotel” will be
       * the same.&lt;/i&gt;&lt;/P&gt;
     *
     * @param integer $id
     */
    public function setId($id)
    {
        $this->id = $id;
    }
    /**
     * set to language code if value has a translation, else null or empty
     *
     * @return string
     */
    public function getLanguage()
    {
        return $this->language;
    }

    /**
     * set to language code if value has a translation, else null or empty
     *
     * @param string $language
     */
    public function setLanguage($language)
    {
        $this->language = $language;
    }
    /**
     * the item value. This is the value that the TEXTGROUP attribute object should set as its value
     *
     * @return string
     */
    public function getValue()
    {
        return $this->value;
    }

    /**
     * the item value. This is the value that the TEXTGROUP attribute object should set as its value
     *
     * @param string $value
     */
    public function setValue($value)
    {
        $this->value = $value;
    }
    /**
     * value text translated according to language, if possible.
     *
     * @return string
     */
    public function getTranslated()
    {
        return $this->translated;
    }

    /**
     * value text translated according to language, if possible.
     *
     * @param string $translated
     */
    public function setTranslated($translated)
    {
        $this->translated = $translated;
    }

    /**
     * Initializes this TextGroupItem from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of TextGroupItem from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'language') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->language = $child;
            $happened = true;
        }
        else if (($xml->localName == 'value') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->value = $child;
            $happened = true;
        }
        else if (($xml->localName == 'translated') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->translated = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of TextGroupItem from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this TextGroupItem to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->id) {
            $writer->startElementNs(null, 'id', null);
            $writer->text($this->id);
            $writer->endElement();
        }
        if ($this->language) {
            $writer->startElementNs(null, 'language', null);
            $writer->text($this->language);
            $writer->endElement();
        }
        if ($this->value) {
            $writer->startElementNs(null, 'value', null);
            $writer->text($this->value);
            $writer->endElement();
        }
        if ($this->translated) {
            $writer->startElementNs(null, 'translated', null);
            $writer->text($this->translated);
            $writer->endElement();
        }
    }
}



namespace App\Traits;

/**
 * (no documentation provided)
 */
class CreditCard
{

    /**
     * CreditCard type
     *
     * @var string
     */
    private $type;

    /**
     * CreditCard number
     *
     * @var string
     */
    private $card_number;

    /**
     * CreditCard cvc
     *
     * @var string
     */
    private $card_cvc;

    /**
     * CreditCard expiry
     *
     * @var string
     */
    private $card_expiry;

    /**
     * CreditCard name on card
     *
     * @var string
     */
    private $card_name;

    /**
     * Constructs a CreditCard from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * CreditCard type
     *
     * @return string
     */
    public function getType()
    {
        return $this->type;
    }

    /**
     * CreditCard type
     *
     * @param string $type
     */
    public function setType($type)
    {
        $this->type = $type;
    }
    /**
     * CreditCard number
     *
     * @return string
     */
    public function getCard_number()
    {
        return $this->card_number;
    }

    /**
     * CreditCard number
     *
     * @param string $card_number
     */
    public function setCard_number($card_number)
    {
        $this->card_number = $card_number;
    }
    /**
     * CreditCard cvc
     *
     * @return string
     */
    public function getCard_cvc()
    {
        return $this->card_cvc;
    }

    /**
     * CreditCard cvc
     *
     * @param string $card_cvc
     */
    public function setCard_cvc($card_cvc)
    {
        $this->card_cvc = $card_cvc;
    }
    /**
     * CreditCard expiry
     *
     * @return string
     */
    public function getCard_expiry()
    {
        return $this->card_expiry;
    }

    /**
     * CreditCard expiry
     *
     * @param string $card_expiry
     */
    public function setCard_expiry($card_expiry)
    {
        $this->card_expiry = $card_expiry;
    }
    /**
     * CreditCard name on card
     *
     * @return string
     */
    public function getCard_name()
    {
        return $this->card_name;
    }

    /**
     * CreditCard name on card
     *
     * @param string $card_name
     */
    public function setCard_name($card_name)
    {
        $this->card_name = $card_name;
    }

    /**
     * Initializes this CreditCard from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of CreditCard from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'type') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->type = $child;
            $happened = true;
        }
        else if (($xml->localName == 'card_number') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->card_number = $child;
            $happened = true;
        }
        else if (($xml->localName == 'card_cvc') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->card_cvc = $child;
            $happened = true;
        }
        else if (($xml->localName == 'card_expiry') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->card_expiry = $child;
            $happened = true;
        }
        else if (($xml->localName == 'card_name') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->card_name = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of CreditCard from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this CreditCard to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->type) {
            $writer->startElementNs(null, 'type', null);
            $writer->text($this->type);
            $writer->endElement();
        }
        if ($this->card_number) {
            $writer->startElementNs(null, 'card_number', null);
            $writer->text($this->card_number);
            $writer->endElement();
        }
        if ($this->card_cvc) {
            $writer->startElementNs(null, 'card_cvc', null);
            $writer->text($this->card_cvc);
            $writer->endElement();
        }
        if ($this->card_expiry) {
            $writer->startElementNs(null, 'card_expiry', null);
            $writer->text($this->card_expiry);
            $writer->endElement();
        }
        if ($this->card_name) {
            $writer->startElementNs(null, 'card_name', null);
            $writer->text($this->card_name);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class CreditCardToken
{

    /**
     * unique token id in this company
     *
     * @var integer
     */
    private $id;

    /**
     * company identification id
     *
     * @var integer
     */
    private $company_id;

    /**
     * Order id this token is related to
     *
     * @var integer
     */
    private $order_id;

    /**
     * Booking id this token is related to, may be omitted if token is related to the order in full
     *
     * @var integer
     */
    private $booking_id;

    /**
     * Creditcard token, max 256 alphanumeric chars
     *
     * @var string
     */
    private $token;

    /**
     * Constructs a CreditCardToken from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * unique token id in this company
     *
     * @return integer
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * unique token id in this company
     *
     * @param integer $id
     */
    public function setId($id)
    {
        $this->id = $id;
    }
    /**
     * company identification id
     *
     * @return integer
     */
    public function getCompany_id()
    {
        return $this->company_id;
    }

    /**
     * company identification id
     *
     * @param integer $company_id
     */
    public function setCompany_id($company_id)
    {
        $this->company_id = $company_id;
    }
    /**
     * Order id this token is related to
     *
     * @return integer
     */
    public function getOrder_id()
    {
        return $this->order_id;
    }

    /**
     * Order id this token is related to
     *
     * @param integer $order_id
     */
    public function setOrder_id($order_id)
    {
        $this->order_id = $order_id;
    }
    /**
     * Booking id this token is related to, may be omitted if token is related to the order in full
     *
     * @return integer
     */
    public function getBooking_id()
    {
        return $this->booking_id;
    }

    /**
     * Booking id this token is related to, may be omitted if token is related to the order in full
     *
     * @param integer $booking_id
     */
    public function setBooking_id($booking_id)
    {
        $this->booking_id = $booking_id;
    }
    /**
     * Creditcard token, max 256 alphanumeric chars
     *
     * @return string
     */
    public function getToken()
    {
        return $this->token;
    }

    /**
     * Creditcard token, max 256 alphanumeric chars
     *
     * @param string $token
     */
    public function setToken($token)
    {
        $this->token = $token;
    }

    /**
     * Initializes this CreditCardToken from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of CreditCardToken from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'company_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->company_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'order_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->order_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'booking_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->booking_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'token') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->token = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of CreditCardToken from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this CreditCardToken to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->id) {
            $writer->startElementNs(null, 'id', null);
            $writer->text($this->id);
            $writer->endElement();
        }
        if ($this->company_id) {
            $writer->startElementNs(null, 'company_id', null);
            $writer->text($this->company_id);
            $writer->endElement();
        }
        if ($this->order_id) {
            $writer->startElementNs(null, 'order_id', null);
            $writer->text($this->order_id);
            $writer->endElement();
        }
        if ($this->booking_id) {
            $writer->startElementNs(null, 'booking_id', null);
            $writer->text($this->booking_id);
            $writer->endElement();
        }
        if ($this->token) {
            $writer->startElementNs(null, 'token', null);
            $writer->text($this->token);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class Customer
{

    /**
     * globally unique id,
     * &lt;p&gt;
     * Please note that the global_customer_id may not always be set (is 0) for a customer. Its use is for
     * linking/identifying the same customer in several company_id&#39;s. And if a customers scope only has
     * been only one company_id, it may not have been created.&lt;/p&gt;
     *
     * @var integer
     */
    private $global_customer_id;

    /**
     * unique id in the company_id which the customer belongs to
     *
     * @var integer
     */
    private $customer_id;

    /**
     * unique id of the company the customer is registered in.
     *
     * @var integer
     */
    private $company_id;

    /**
     * given name of the customer
     *
     * @var string
     */
    private $given_name;

    /**
     * the last name of the customer
     *
     * @var string
     */
    private $surname;

    /**
     * company name
     *
     * @var string
     */
    private $company_name;

    /**
     * street name or address of the customer
     *
     * @var string
     */
    private $address;

    /**
     * zip code
     *
     * @var string
     */
    private $zip_code;

    /**
     * city
     *
     * @var string
     */
    private $city;

    /**
     * iso 3166 country id (see get_country_codes command)
     *
     * @var integer
     */
    private $country_code;

    /**
     * phone number (landline)
     *
     * @var string
     */
    private $phone;

    /**
     * mobile phone number
     *
     * @var string
     */
    private $mobile;

    /**
     * email address
     *
     * @var string
     */
    private $email;

    /**
     * passport number
     *
     * @var string
     */
    private $passport_no;

    /**
     * last customer record change timestamp
     *
     * @var integer
     */
    private $changed_date;

    /**
     * Notes regarding customer
     *
     * @var string
     */
    private $notes;

    /**
     * iata code on customer
     *
     * @var string
     */
    private $iata_id;

    /**
     * extra data field1, hotel/company specific
     *
     * @var string
     */
    private $extra1;

    /**
     * extra data field2, hotel/company specific
     *
     * @var string
     */
    private $extra2;

    /**
     * extra data field3, hotel/company specific
     *
     * @var string
     */
    private $extra3;

    /**
     * extra data field4, hotel/company specific
     *
     * @var string
     */
    private $extra4;

    /**
     * extra data field5, hotel/company specific
     *
     * @var string
     */
    private $extra5;

    /**
     * customerType see enum customerType
     *
     * @var string
     */
    private $type;

    /**
     * list of customerCategory objects this customer belongs to
     *
     * @var \App\Traits\CustomerCategory[]
     */
    private $customer_categories;

    /**
     * list of person objects associated with the customer, f.ex. in case customer is a company
     *
     * @var \App\Traits\Person[]
     */
    private $persons;

    /**
     * &quot;peppolid&quot; Pan-European Procurement Online id, used for organizational id, max 25 char string
     *
     * @var string
     */
    private $peppolid;

    /**
     * birthday for the customer, if set
     *
     * @var integer
     */
    private $birthday;

    /**
     * Constructs a Customer from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * globally unique id,
       * &lt;p&gt;
       * Please note that the global_customer_id may not always be set (is 0) for a customer. Its use is for
       * linking/identifying the same customer in several company_id&#39;s. And if a customers scope only has
       * been only one company_id, it may not have been created.&lt;/p&gt;
     *
     * @return integer
     */
    public function getGlobal_customer_id()
    {
        return $this->global_customer_id;
    }

    /**
     * globally unique id,
       * &lt;p&gt;
       * Please note that the global_customer_id may not always be set (is 0) for a customer. Its use is for
       * linking/identifying the same customer in several company_id&#39;s. And if a customers scope only has
       * been only one company_id, it may not have been created.&lt;/p&gt;
     *
     * @param integer $global_customer_id
     */
    public function setGlobal_customer_id($global_customer_id)
    {
        $this->global_customer_id = $global_customer_id;
    }
    /**
     * unique id in the company_id which the customer belongs to
     *
     * @return integer
     */
    public function getCustomer_id()
    {
        return $this->customer_id;
    }

    /**
     * unique id in the company_id which the customer belongs to
     *
     * @param integer $customer_id
     */
    public function setCustomer_id($customer_id)
    {
        $this->customer_id = $customer_id;
    }
    /**
     * unique id of the company the customer is registered in.
     *
     * @return integer
     */
    public function getCompany_id()
    {
        return $this->company_id;
    }

    /**
     * unique id of the company the customer is registered in.
     *
     * @param integer $company_id
     */
    public function setCompany_id($company_id)
    {
        $this->company_id = $company_id;
    }
    /**
     * given name of the customer
     *
     * @return string
     */
    public function getGiven_name()
    {
        return $this->given_name;
    }

    /**
     * given name of the customer
     *
     * @param string $given_name
     */
    public function setGiven_name($given_name)
    {
        $this->given_name = $given_name;
    }
    /**
     * the last name of the customer
     *
     * @return string
     */
    public function getSurname()
    {
        return $this->surname;
    }

    /**
     * the last name of the customer
     *
     * @param string $surname
     */
    public function setSurname($surname)
    {
        $this->surname = $surname;
    }
    /**
     * company name
     *
     * @return string
     */
    public function getCompany_name()
    {
        return $this->company_name;
    }

    /**
     * company name
     *
     * @param string $company_name
     */
    public function setCompany_name($company_name)
    {
        $this->company_name = $company_name;
    }
    /**
     * street name or address of the customer
     *
     * @return string
     */
    public function getAddress()
    {
        return $this->address;
    }

    /**
     * street name or address of the customer
     *
     * @param string $address
     */
    public function setAddress($address)
    {
        $this->address = $address;
    }
    /**
     * zip code
     *
     * @return string
     */
    public function getZip_code()
    {
        return $this->zip_code;
    }

    /**
     * zip code
     *
     * @param string $zip_code
     */
    public function setZip_code($zip_code)
    {
        $this->zip_code = $zip_code;
    }
    /**
     * city
     *
     * @return string
     */
    public function getCity()
    {
        return $this->city;
    }

    /**
     * city
     *
     * @param string $city
     */
    public function setCity($city)
    {
        $this->city = $city;
    }
    /**
     * iso 3166 country id (see get_country_codes command)
     *
     * @return integer
     */
    public function getCountry_code()
    {
        return $this->country_code;
    }

    /**
     * iso 3166 country id (see get_country_codes command)
     *
     * @param integer $country_code
     */
    public function setCountry_code($country_code)
    {
        $this->country_code = $country_code;
    }
    /**
     * phone number (landline)
     *
     * @return string
     */
    public function getPhone()
    {
        return $this->phone;
    }

    /**
     * phone number (landline)
     *
     * @param string $phone
     */
    public function setPhone($phone)
    {
        $this->phone = $phone;
    }
    /**
     * mobile phone number
     *
     * @return string
     */
    public function getMobile()
    {
        return $this->mobile;
    }

    /**
     * mobile phone number
     *
     * @param string $mobile
     */
    public function setMobile($mobile)
    {
        $this->mobile = $mobile;
    }
    /**
     * email address
     *
     * @return string
     */
    public function getEmail()
    {
        return $this->email;
    }

    /**
     * email address
     *
     * @param string $email
     */
    public function setEmail($email)
    {
        $this->email = $email;
    }
    /**
     * passport number
     *
     * @return string
     */
    public function getPassport_no()
    {
        return $this->passport_no;
    }

    /**
     * passport number
     *
     * @param string $passport_no
     */
    public function setPassport_no($passport_no)
    {
        $this->passport_no = $passport_no;
    }
    /**
     * last customer record change timestamp
     *
     * @return integer
     */
    public function getChanged_date()
    {
        return $this->changed_date;
    }

    /**
     * last customer record change timestamp
     *
     * @param integer $changed_date
     */
    public function setChanged_date($changed_date)
    {
        $this->changed_date = $changed_date;
    }
    /**
     * Notes regarding customer
     *
     * @return string
     */
    public function getNotes()
    {
        return $this->notes;
    }

    /**
     * Notes regarding customer
     *
     * @param string $notes
     */
    public function setNotes($notes)
    {
        $this->notes = $notes;
    }
    /**
     * iata code on customer
     *
     * @return string
     */
    public function getIata_id()
    {
        return $this->iata_id;
    }

    /**
     * iata code on customer
     *
     * @param string $iata_id
     */
    public function setIata_id($iata_id)
    {
        $this->iata_id = $iata_id;
    }
    /**
     * extra data field1, hotel/company specific
     *
     * @return string
     */
    public function getExtra1()
    {
        return $this->extra1;
    }

    /**
     * extra data field1, hotel/company specific
     *
     * @param string $extra1
     */
    public function setExtra1($extra1)
    {
        $this->extra1 = $extra1;
    }
    /**
     * extra data field2, hotel/company specific
     *
     * @return string
     */
    public function getExtra2()
    {
        return $this->extra2;
    }

    /**
     * extra data field2, hotel/company specific
     *
     * @param string $extra2
     */
    public function setExtra2($extra2)
    {
        $this->extra2 = $extra2;
    }
    /**
     * extra data field3, hotel/company specific
     *
     * @return string
     */
    public function getExtra3()
    {
        return $this->extra3;
    }

    /**
     * extra data field3, hotel/company specific
     *
     * @param string $extra3
     */
    public function setExtra3($extra3)
    {
        $this->extra3 = $extra3;
    }
    /**
     * extra data field4, hotel/company specific
     *
     * @return string
     */
    public function getExtra4()
    {
        return $this->extra4;
    }

    /**
     * extra data field4, hotel/company specific
     *
     * @param string $extra4
     */
    public function setExtra4($extra4)
    {
        $this->extra4 = $extra4;
    }
    /**
     * extra data field5, hotel/company specific
     *
     * @return string
     */
    public function getExtra5()
    {
        return $this->extra5;
    }

    /**
     * extra data field5, hotel/company specific
     *
     * @param string $extra5
     */
    public function setExtra5($extra5)
    {
        $this->extra5 = $extra5;
    }
    /**
     * customerType see enum customerType
     *
     * @return string
     */
    public function getType()
    {
        return $this->type;
    }

    /**
     * customerType see enum customerType
     *
     * @param string $type
     */
    public function setType($type)
    {
        $this->type = $type;
    }
    /**
     * list of customerCategory objects this customer belongs to
     *
     * @return \App\Traits\CustomerCategory[]
     */
    public function getCustomer_categories()
    {
        return $this->customer_categories;
    }

    /**
     * list of customerCategory objects this customer belongs to
     *
     * @param \App\Traits\CustomerCategory[] $customer_categories
     */
    public function setCustomer_categories($customer_categories)
    {
        $this->customer_categories = $customer_categories;
    }
    /**
     * list of person objects associated with the customer, f.ex. in case customer is a company
     *
     * @return \App\Traits\Person[]
     */
    public function getPersons()
    {
        return $this->persons;
    }

    /**
     * list of person objects associated with the customer, f.ex. in case customer is a company
     *
     * @param \App\Traits\Person[] $persons
     */
    public function setPersons($persons)
    {
        $this->persons = $persons;
    }
    /**
     * &quot;peppolid&quot; Pan-European Procurement Online id, used for organizational id, max 25 char string
     *
     * @return string
     */
    public function getPeppolid()
    {
        return $this->peppolid;
    }

    /**
     * &quot;peppolid&quot; Pan-European Procurement Online id, used for organizational id, max 25 char string
     *
     * @param string $peppolid
     */
    public function setPeppolid($peppolid)
    {
        $this->peppolid = $peppolid;
    }
    /**
     * birthday for the customer, if set
     *
     * @return integer
     */
    public function getBirthday()
    {
        return $this->birthday;
    }

    /**
     * birthday for the customer, if set
     *
     * @param integer $birthday
     */
    public function setBirthday($birthday)
    {
        $this->birthday = $birthday;
    }

    /**
     * Initializes this Customer from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of Customer from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'global_customer_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->global_customer_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'customer_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->customer_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'company_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->company_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'given_name') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->given_name = $child;
            $happened = true;
        }
        else if (($xml->localName == 'surname') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->surname = $child;
            $happened = true;
        }
        else if (($xml->localName == 'company_name') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->company_name = $child;
            $happened = true;
        }
        else if (($xml->localName == 'address') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->address = $child;
            $happened = true;
        }
        else if (($xml->localName == 'zip_code') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->zip_code = $child;
            $happened = true;
        }
        else if (($xml->localName == 'city') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->city = $child;
            $happened = true;
        }
        else if (($xml->localName == 'country_code') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->country_code = $child;
            $happened = true;
        }
        else if (($xml->localName == 'phone') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->phone = $child;
            $happened = true;
        }
        else if (($xml->localName == 'mobile') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->mobile = $child;
            $happened = true;
        }
        else if (($xml->localName == 'email') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->email = $child;
            $happened = true;
        }
        else if (($xml->localName == 'passport_no') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->passport_no = $child;
            $happened = true;
        }
        else if (($xml->localName == 'changed_date') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->changed_date = $child;
            $happened = true;
        }
        else if (($xml->localName == 'notes') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->notes = $child;
            $happened = true;
        }
        else if (($xml->localName == 'iata_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->iata_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'extra1') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->extra1 = $child;
            $happened = true;
        }
        else if (($xml->localName == 'extra2') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->extra2 = $child;
            $happened = true;
        }
        else if (($xml->localName == 'extra3') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->extra3 = $child;
            $happened = true;
        }
        else if (($xml->localName == 'extra4') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->extra4 = $child;
            $happened = true;
        }
        else if (($xml->localName == 'extra5') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->extra5 = $child;
            $happened = true;
        }
        else if (($xml->localName == 'type') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->type = $child;
            $happened = true;
        }
        else if (($xml->localName == 'customer_categories') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\CustomerCategory($xml);
            if (!isset($this->customer_categories)) {
                $this->customer_categories = array();
            }
            array_push($this->customer_categories, $child);
            $happened = true;
        }
        else if (($xml->localName == 'persons') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\Person($xml);
            if (!isset($this->persons)) {
                $this->persons = array();
            }
            array_push($this->persons, $child);
            $happened = true;
        }
        else if (($xml->localName == 'peppolid') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->peppolid = $child;
            $happened = true;
        }
        else if (($xml->localName == 'birthday') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->birthday = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of Customer from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this Customer to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->global_customer_id) {
            $writer->startElementNs(null, 'global_customer_id', null);
            $writer->text($this->global_customer_id);
            $writer->endElement();
        }
        if ($this->customer_id) {
            $writer->startElementNs(null, 'customer_id', null);
            $writer->text($this->customer_id);
            $writer->endElement();
        }
        if ($this->company_id) {
            $writer->startElementNs(null, 'company_id', null);
            $writer->text($this->company_id);
            $writer->endElement();
        }
        if ($this->given_name) {
            $writer->startElementNs(null, 'given_name', null);
            $writer->text($this->given_name);
            $writer->endElement();
        }
        if ($this->surname) {
            $writer->startElementNs(null, 'surname', null);
            $writer->text($this->surname);
            $writer->endElement();
        }
        if ($this->company_name) {
            $writer->startElementNs(null, 'company_name', null);
            $writer->text($this->company_name);
            $writer->endElement();
        }
        if ($this->address) {
            $writer->startElementNs(null, 'address', null);
            $writer->text($this->address);
            $writer->endElement();
        }
        if ($this->zip_code) {
            $writer->startElementNs(null, 'zip_code', null);
            $writer->text($this->zip_code);
            $writer->endElement();
        }
        if ($this->city) {
            $writer->startElementNs(null, 'city', null);
            $writer->text($this->city);
            $writer->endElement();
        }
        if ($this->country_code) {
            $writer->startElementNs(null, 'country_code', null);
            $writer->text($this->country_code);
            $writer->endElement();
        }
        if ($this->phone) {
            $writer->startElementNs(null, 'phone', null);
            $writer->text($this->phone);
            $writer->endElement();
        }
        if ($this->mobile) {
            $writer->startElementNs(null, 'mobile', null);
            $writer->text($this->mobile);
            $writer->endElement();
        }
        if ($this->email) {
            $writer->startElementNs(null, 'email', null);
            $writer->text($this->email);
            $writer->endElement();
        }
        if ($this->passport_no) {
            $writer->startElementNs(null, 'passport_no', null);
            $writer->text($this->passport_no);
            $writer->endElement();
        }
        if ($this->changed_date) {
            $writer->startElementNs(null, 'changed_date', null);
            $writer->text($this->changed_date);
            $writer->endElement();
        }
        if ($this->notes) {
            $writer->startElementNs(null, 'notes', null);
            $writer->text($this->notes);
            $writer->endElement();
        }
        if ($this->iata_id) {
            $writer->startElementNs(null, 'iata_id', null);
            $writer->text($this->iata_id);
            $writer->endElement();
        }
        if ($this->extra1) {
            $writer->startElementNs(null, 'extra1', null);
            $writer->text($this->extra1);
            $writer->endElement();
        }
        if ($this->extra2) {
            $writer->startElementNs(null, 'extra2', null);
            $writer->text($this->extra2);
            $writer->endElement();
        }
        if ($this->extra3) {
            $writer->startElementNs(null, 'extra3', null);
            $writer->text($this->extra3);
            $writer->endElement();
        }
        if ($this->extra4) {
            $writer->startElementNs(null, 'extra4', null);
            $writer->text($this->extra4);
            $writer->endElement();
        }
        if ($this->extra5) {
            $writer->startElementNs(null, 'extra5', null);
            $writer->text($this->extra5);
            $writer->endElement();
        }
        if ($this->type) {
            $writer->startElementNs(null, 'type', null);
            $writer->text($this->type);
            $writer->endElement();
        }
        if ($this->customer_categories) {
            foreach ($this->customer_categories as $i => $x) {
                $writer->startElementNs(null, 'customer_categories', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->persons) {
            foreach ($this->persons as $i => $x) {
                $writer->startElementNs(null, 'persons', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->peppolid) {
            $writer->startElementNs(null, 'peppolid', null);
            $writer->text($this->peppolid);
            $writer->endElement();
        }
        if ($this->birthday) {
            $writer->startElementNs(null, 'birthday', null);
            $writer->text($this->birthday);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class DocumentReference
{

    /**
     * &lt;p&gt;unique document id&lt;/p&gt;
     *
     * “Public” available documents may be retrieved if &lt;i&gt;docid&lt;/i&gt; and &lt;i&gt;filename&lt;/i&gt; is known, from the url:
     * &lt;code&gt;
     * https://visdoc.visbook.com/publish/[docid]/[filename]
     * &lt;/code&gt;
     *
     * @var integer
     */
    private $doc_id;

    /**
     * company id
     *
     * @var integer
     */
    private $company_id;

    /**
     * given filename of the reference
     *
     * @var string
     */
    private $filename;

    /**
     * the timestamp the document reference was registered
     *
     * @var integer
     */
    private $registration_date;

    /**
     * the timestamp the document reference was changed
     *
     * @var integer
     */
    private $changed_date;

    /**
     * Constructs a DocumentReference from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * &lt;p&gt;unique document id&lt;/p&gt;
       *
       * “Public” available documents may be retrieved if &lt;i&gt;docid&lt;/i&gt; and &lt;i&gt;filename&lt;/i&gt; is known, from the url:
       * &lt;code&gt;
       * https://visdoc.visbook.com/publish/[docid]/[filename]
       * &lt;/code&gt;
     *
     * @return integer
     */
    public function getDoc_id()
    {
        return $this->doc_id;
    }

    /**
     * &lt;p&gt;unique document id&lt;/p&gt;
       *
       * “Public” available documents may be retrieved if &lt;i&gt;docid&lt;/i&gt; and &lt;i&gt;filename&lt;/i&gt; is known, from the url:
       * &lt;code&gt;
       * https://visdoc.visbook.com/publish/[docid]/[filename]
       * &lt;/code&gt;
     *
     * @param integer $doc_id
     */
    public function setDoc_id($doc_id)
    {
        $this->doc_id = $doc_id;
    }
    /**
     * company id
     *
     * @return integer
     */
    public function getCompany_id()
    {
        return $this->company_id;
    }

    /**
     * company id
     *
     * @param integer $company_id
     */
    public function setCompany_id($company_id)
    {
        $this->company_id = $company_id;
    }
    /**
     * given filename of the reference
     *
     * @return string
     */
    public function getFilename()
    {
        return $this->filename;
    }

    /**
     * given filename of the reference
     *
     * @param string $filename
     */
    public function setFilename($filename)
    {
        $this->filename = $filename;
    }
    /**
     * the timestamp the document reference was registered
     *
     * @return integer
     */
    public function getRegistration_date()
    {
        return $this->registration_date;
    }

    /**
     * the timestamp the document reference was registered
     *
     * @param integer $registration_date
     */
    public function setRegistration_date($registration_date)
    {
        $this->registration_date = $registration_date;
    }
    /**
     * the timestamp the document reference was changed
     *
     * @return integer
     */
    public function getChanged_date()
    {
        return $this->changed_date;
    }

    /**
     * the timestamp the document reference was changed
     *
     * @param integer $changed_date
     */
    public function setChanged_date($changed_date)
    {
        $this->changed_date = $changed_date;
    }

    /**
     * Initializes this DocumentReference from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of DocumentReference from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'doc_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->doc_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'company_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->company_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'filename') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->filename = $child;
            $happened = true;
        }
        else if (($xml->localName == 'registration_date') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->registration_date = $child;
            $happened = true;
        }
        else if (($xml->localName == 'changed_date') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->changed_date = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of DocumentReference from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this DocumentReference to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->doc_id) {
            $writer->startElementNs(null, 'doc_id', null);
            $writer->text($this->doc_id);
            $writer->endElement();
        }
        if ($this->company_id) {
            $writer->startElementNs(null, 'company_id', null);
            $writer->text($this->company_id);
            $writer->endElement();
        }
        if ($this->filename) {
            $writer->startElementNs(null, 'filename', null);
            $writer->text($this->filename);
            $writer->endElement();
        }
        if ($this->registration_date) {
            $writer->startElementNs(null, 'registration_date', null);
            $writer->text($this->registration_date);
            $writer->endElement();
        }
        if ($this->changed_date) {
            $writer->startElementNs(null, 'changed_date', null);
            $writer->text($this->changed_date);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class Event
{

    /**
     * Unique event_id - unique in company_id scope
     *
     * @var integer
     */
    private $event_id;

    /**
     * the company id the event belongs to
     *
     * @var integer
     */
    private $company_id;

    /**
     * Event name
     *
     * @var string
     */
    private $name;

    /**
     * Event notes / description
     *
     * @var string
     */
    private $note;

    /**
     * Constructs a Event from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * Unique event_id - unique in company_id scope
     *
     * @return integer
     */
    public function getEvent_id()
    {
        return $this->event_id;
    }

    /**
     * Unique event_id - unique in company_id scope
     *
     * @param integer $event_id
     */
    public function setEvent_id($event_id)
    {
        $this->event_id = $event_id;
    }
    /**
     * the company id the event belongs to
     *
     * @return integer
     */
    public function getCompany_id()
    {
        return $this->company_id;
    }

    /**
     * the company id the event belongs to
     *
     * @param integer $company_id
     */
    public function setCompany_id($company_id)
    {
        $this->company_id = $company_id;
    }
    /**
     * Event name
     *
     * @return string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * Event name
     *
     * @param string $name
     */
    public function setName($name)
    {
        $this->name = $name;
    }
    /**
     * Event notes / description
     *
     * @return string
     */
    public function getNote()
    {
        return $this->note;
    }

    /**
     * Event notes / description
     *
     * @param string $note
     */
    public function setNote($note)
    {
        $this->note = $note;
    }

    /**
     * Initializes this Event from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of Event from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'event_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->event_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'company_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->company_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'name') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->name = $child;
            $happened = true;
        }
        else if (($xml->localName == 'note') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->note = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of Event from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this Event to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->event_id) {
            $writer->startElementNs(null, 'event_id', null);
            $writer->text($this->event_id);
            $writer->endElement();
        }
        if ($this->company_id) {
            $writer->startElementNs(null, 'company_id', null);
            $writer->text($this->company_id);
            $writer->endElement();
        }
        if ($this->name) {
            $writer->startElementNs(null, 'name', null);
            $writer->text($this->name);
            $writer->endElement();
        }
        if ($this->note) {
            $writer->startElementNs(null, 'note', null);
            $writer->text($this->note);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class ExternalBookingReference
{

    /**
     * externalBookingReferenceType enum
     *
     * @var string
     */
    private $type;

    /**
     * reference id (string)
     *
     * @var string
     */
    private $reference;

    /**
     * Constructs a ExternalBookingReference from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * externalBookingReferenceType enum
     *
     * @return string
     */
    public function getType()
    {
        return $this->type;
    }

    /**
     * externalBookingReferenceType enum
     *
     * @param string $type
     */
    public function setType($type)
    {
        $this->type = $type;
    }
    /**
     * reference id (string)
     *
     * @return string
     */
    public function getReference()
    {
        return $this->reference;
    }

    /**
     * reference id (string)
     *
     * @param string $reference
     */
    public function setReference($reference)
    {
        $this->reference = $reference;
    }

    /**
     * Initializes this ExternalBookingReference from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of ExternalBookingReference from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'type') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->type = $child;
            $happened = true;
        }
        else if (($xml->localName == 'reference') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->reference = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of ExternalBookingReference from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this ExternalBookingReference to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->type) {
            $writer->startElementNs(null, 'type', null);
            $writer->text($this->type);
            $writer->endElement();
        }
        if ($this->reference) {
            $writer->startElementNs(null, 'reference', null);
            $writer->text($this->reference);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class GeoQuery
{

    /**
     * latitude, in decimal degrees
     *
     * @var double
     */
    private $latitude;

    /**
     * longitude, in decimal degrees
     *
     * @var double
     */
    private $longitude;

    /**
     * in kilometers
     *
     * @var double
     */
    private $distance;

    /**
     * set to true if resulting objects on a product query default should
     * match if the company coordinates match, and product coordinates is ignored, else only
     * produtcs with coordinates set is returned. In most cases, &quot;true&quot; should be used.
     *
     * @var boolean
     */
    private $product_inherit_company;

    /**
     * Constructs a GeoQuery from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * latitude, in decimal degrees
     *
     * @return double
     */
    public function getLatitude()
    {
        return $this->latitude;
    }

    /**
     * latitude, in decimal degrees
     *
     * @param double $latitude
     */
    public function setLatitude($latitude)
    {
        $this->latitude = $latitude;
    }
    /**
     * longitude, in decimal degrees
     *
     * @return double
     */
    public function getLongitude()
    {
        return $this->longitude;
    }

    /**
     * longitude, in decimal degrees
     *
     * @param double $longitude
     */
    public function setLongitude($longitude)
    {
        $this->longitude = $longitude;
    }
    /**
     * in kilometers
     *
     * @return double
     */
    public function getDistance()
    {
        return $this->distance;
    }

    /**
     * in kilometers
     *
     * @param double $distance
     */
    public function setDistance($distance)
    {
        $this->distance = $distance;
    }
    /**
     * set to true if resulting objects on a product query default should
       * match if the company coordinates match, and product coordinates is ignored, else only
       * produtcs with coordinates set is returned. In most cases, &quot;true&quot; should be used.
     *
     * @return boolean
     */
    public function getProduct_inherit_company()
    {
        return $this->product_inherit_company;
    }

    /**
     * set to true if resulting objects on a product query default should
       * match if the company coordinates match, and product coordinates is ignored, else only
       * produtcs with coordinates set is returned. In most cases, &quot;true&quot; should be used.
     *
     * @param boolean $product_inherit_company
     */
    public function setProduct_inherit_company($product_inherit_company)
    {
        $this->product_inherit_company = $product_inherit_company;
    }

    /**
     * Initializes this GeoQuery from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of GeoQuery from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'latitude') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->latitude = $child;
            $happened = true;
        }
        else if (($xml->localName == 'longitude') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->longitude = $child;
            $happened = true;
        }
        else if (($xml->localName == 'distance') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->distance = $child;
            $happened = true;
        }
        else if (($xml->localName == 'product_inherit_company') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->product_inherit_company = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of GeoQuery from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this GeoQuery to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->latitude) {
            $writer->startElementNs(null, 'latitude', null);
            $writer->text($this->latitude);
            $writer->endElement();
        }
        if ($this->longitude) {
            $writer->startElementNs(null, 'longitude', null);
            $writer->text($this->longitude);
            $writer->endElement();
        }
        if ($this->distance) {
            $writer->startElementNs(null, 'distance', null);
            $writer->text($this->distance);
            $writer->endElement();
        }
        if ($this->product_inherit_company) {
            $writer->startElementNs(null, 'product_inherit_company', null);
            $writer->text($this->product_inherit_company);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class Happening
{

    /**
     * Unique happening_id - unique in company_id scope
     *
     * @var integer
     */
    private $happening_id;

    /**
     * the company id the happening belongs to
     *
     * @var integer
     */
    private $company_id;

    /**
     * Happening name
     *
     * @var string
     */
    private $name;

    /**
     * Happening from date
     *
     * @var integer
     */
    private $from_date;

    /**
     * Happening to date
     *
     * @var integer
     */
    private $to_date;

    /**
     * Constructs a Happening from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * Unique happening_id - unique in company_id scope
     *
     * @return integer
     */
    public function getHappening_id()
    {
        return $this->happening_id;
    }

    /**
     * Unique happening_id - unique in company_id scope
     *
     * @param integer $happening_id
     */
    public function setHappening_id($happening_id)
    {
        $this->happening_id = $happening_id;
    }
    /**
     * the company id the happening belongs to
     *
     * @return integer
     */
    public function getCompany_id()
    {
        return $this->company_id;
    }

    /**
     * the company id the happening belongs to
     *
     * @param integer $company_id
     */
    public function setCompany_id($company_id)
    {
        $this->company_id = $company_id;
    }
    /**
     * Happening name
     *
     * @return string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * Happening name
     *
     * @param string $name
     */
    public function setName($name)
    {
        $this->name = $name;
    }
    /**
     * Happening from date
     *
     * @return integer
     */
    public function getFrom_date()
    {
        return $this->from_date;
    }

    /**
     * Happening from date
     *
     * @param integer $from_date
     */
    public function setFrom_date($from_date)
    {
        $this->from_date = $from_date;
    }
    /**
     * Happening to date
     *
     * @return integer
     */
    public function getTo_date()
    {
        return $this->to_date;
    }

    /**
     * Happening to date
     *
     * @param integer $to_date
     */
    public function setTo_date($to_date)
    {
        $this->to_date = $to_date;
    }

    /**
     * Initializes this Happening from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of Happening from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'happening_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->happening_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'company_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->company_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'name') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->name = $child;
            $happened = true;
        }
        else if (($xml->localName == 'from_date') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->from_date = $child;
            $happened = true;
        }
        else if (($xml->localName == 'to_date') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->to_date = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of Happening from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this Happening to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->happening_id) {
            $writer->startElementNs(null, 'happening_id', null);
            $writer->text($this->happening_id);
            $writer->endElement();
        }
        if ($this->company_id) {
            $writer->startElementNs(null, 'company_id', null);
            $writer->text($this->company_id);
            $writer->endElement();
        }
        if ($this->name) {
            $writer->startElementNs(null, 'name', null);
            $writer->text($this->name);
            $writer->endElement();
        }
        if ($this->from_date) {
            $writer->startElementNs(null, 'from_date', null);
            $writer->text($this->from_date);
            $writer->endElement();
        }
        if ($this->to_date) {
            $writer->startElementNs(null, 'to_date', null);
            $writer->text($this->to_date);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class Order
{

    /**
     * unique id in the company_id which the order belongs to
     *
     * @var integer
     */
    private $order_id;

    /**
     * the company id the order belongs to
     *
     * @var integer
     */
    private $company_id;

    /**
     * if the order has been invoiced, this will contain the invoice id
     *
     * @var integer
     */
    private $invoice_id;

    /**
     * when using store_order_multi, multi company orders identifies an globally unique id for a collection of orders in multiple companies.
     *
     * @var integer
     */
    private $multi_order_id;

    /**
     * if the order has been invoiced, this will contain the date when it was invoiced
     *
     * @var integer
     */
    private $invoice_date;

    /**
     * if invoiced, the due date of the invoice
     *
     * @var integer
     */
    private $due_date;

    /**
     * if the order has been paid in full, this will contain the pay date
     *
     * @var integer
     */
    private $payed_date;

    /**
     * if the order has been cancelled, this will contain the date of cancellation
     *
     * @var integer
     */
    private $cancel_date;

    /**
     * the date the order was last changed.
     *
     * @var integer
     */
    private $changed_date;

    /**
     * the date when the order was first registered
     *
     * @var integer
     */
    private $registration_date;

    /**
     * contains the customer object that this order is related to
     *
     * @var \App\Traits\Customer
     */
    private $customer;

    /**
     * if other than specified in field &lt;i&gt;customer&lt;/i&gt;, is set to a customer object for the arriving customer
     *
     * @var \App\Traits\Customer
     */
    private $arrival_customer;

    /**
     * optional another customer object attached to the order.
     *
     * @var \App\Traits\Customer
     */
    private $other_customer;

    /**
     * a list of booking objects that this order contains
     *
     * @var \App\Traits\Booking[]
     */
    private $bookings;

    /**
     * the current status of the order
     *
     * @var string
     */
    private $order_status;

    /**
     * the sum total on the order,
     *
     * @var double
     */
    private $order_sum;

    /**
     * the outstanding amount to be paid on the order,
     *
     * @var double
     */
    private $order_balance;

    /**
     * list of payments done on the order
     *
     * @var \App\Traits\Payment[]
     */
    private $payments;

    /**
     * if invoiced, and enabled on the company, contains the ocr kid string created for the order
     *
     * @var string
     */
    private $kid;

    /**
     * related order, for creditnote
     *
     * @var integer
     */
    private $related_order;

    /**
     * SysStatus
     *
     * @var string
     */
    private $sys_status;

    /**
     * list of external booking references
     *
     * @var \App\Traits\ExternalBookingReference[]
     */
    private $external_booking_references;

    /**
     * UID
     *
     * @var integer
     */
    private $owner_id;

    /**
     * last changed by id
     *
     * @var integer
     */
    private $changed_id;

    /**
     * Custom reference
     *
     * @var string
     */
    private $custom_reference;

    /**
     * checkout payment rule
     *
     * @var integer
     */
    private $checkout_payment_rule;

    /**
     * checkout payment rule note
     *
     * @var string
     */
    private $checkout_payment_rule_note;

    /**
     * internal_note
     *
     * @var string
     */
    private $internal_note;

    /**
     * Constructs a Order from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * unique id in the company_id which the order belongs to
     *
     * @return integer
     */
    public function getOrder_id()
    {
        return $this->order_id;
    }

    /**
     * unique id in the company_id which the order belongs to
     *
     * @param integer $order_id
     */
    public function setOrder_id($order_id)
    {
        $this->order_id = $order_id;
    }
    /**
     * the company id the order belongs to
     *
     * @return integer
     */
    public function getCompany_id()
    {
        return $this->company_id;
    }

    /**
     * the company id the order belongs to
     *
     * @param integer $company_id
     */
    public function setCompany_id($company_id)
    {
        $this->company_id = $company_id;
    }
    /**
     * if the order has been invoiced, this will contain the invoice id
     *
     * @return integer
     */
    public function getInvoice_id()
    {
        return $this->invoice_id;
    }

    /**
     * if the order has been invoiced, this will contain the invoice id
     *
     * @param integer $invoice_id
     */
    public function setInvoice_id($invoice_id)
    {
        $this->invoice_id = $invoice_id;
    }
    /**
     * when using store_order_multi, multi company orders identifies an globally unique id for a collection of orders in multiple companies.
     *
     * @return integer
     */
    public function getMulti_order_id()
    {
        return $this->multi_order_id;
    }

    /**
     * when using store_order_multi, multi company orders identifies an globally unique id for a collection of orders in multiple companies.
     *
     * @param integer $multi_order_id
     */
    public function setMulti_order_id($multi_order_id)
    {
        $this->multi_order_id = $multi_order_id;
    }
    /**
     * if the order has been invoiced, this will contain the date when it was invoiced
     *
     * @return integer
     */
    public function getInvoice_date()
    {
        return $this->invoice_date;
    }

    /**
     * if the order has been invoiced, this will contain the date when it was invoiced
     *
     * @param integer $invoice_date
     */
    public function setInvoice_date($invoice_date)
    {
        $this->invoice_date = $invoice_date;
    }
    /**
     * if invoiced, the due date of the invoice
     *
     * @return integer
     */
    public function getDue_date()
    {
        return $this->due_date;
    }

    /**
     * if invoiced, the due date of the invoice
     *
     * @param integer $due_date
     */
    public function setDue_date($due_date)
    {
        $this->due_date = $due_date;
    }
    /**
     * if the order has been paid in full, this will contain the pay date
     *
     * @return integer
     */
    public function getPayed_date()
    {
        return $this->payed_date;
    }

    /**
     * if the order has been paid in full, this will contain the pay date
     *
     * @param integer $payed_date
     */
    public function setPayed_date($payed_date)
    {
        $this->payed_date = $payed_date;
    }
    /**
     * if the order has been cancelled, this will contain the date of cancellation
     *
     * @return integer
     */
    public function getCancel_date()
    {
        return $this->cancel_date;
    }

    /**
     * if the order has been cancelled, this will contain the date of cancellation
     *
     * @param integer $cancel_date
     */
    public function setCancel_date($cancel_date)
    {
        $this->cancel_date = $cancel_date;
    }
    /**
     * the date the order was last changed.
     *
     * @return integer
     */
    public function getChanged_date()
    {
        return $this->changed_date;
    }

    /**
     * the date the order was last changed.
     *
     * @param integer $changed_date
     */
    public function setChanged_date($changed_date)
    {
        $this->changed_date = $changed_date;
    }
    /**
     * the date when the order was first registered
     *
     * @return integer
     */
    public function getRegistration_date()
    {
        return $this->registration_date;
    }

    /**
     * the date when the order was first registered
     *
     * @param integer $registration_date
     */
    public function setRegistration_date($registration_date)
    {
        $this->registration_date = $registration_date;
    }
    /**
     * contains the customer object that this order is related to
     *
     * @return \App\Traits\Customer
     */
    public function getCustomer()
    {
        return $this->customer;
    }

    /**
     * contains the customer object that this order is related to
     *
     * @param \App\Traits\Customer $customer
     */
    public function setCustomer($customer)
    {
        $this->customer = $customer;
    }
    /**
     * if other than specified in field &lt;i&gt;customer&lt;/i&gt;, is set to a customer object for the arriving customer
     *
     * @return \App\Traits\Customer
     */
    public function getArrival_customer()
    {
        return $this->arrival_customer;
    }

    /**
     * if other than specified in field &lt;i&gt;customer&lt;/i&gt;, is set to a customer object for the arriving customer
     *
     * @param \App\Traits\Customer $arrival_customer
     */
    public function setArrival_customer($arrival_customer)
    {
        $this->arrival_customer = $arrival_customer;
    }
    /**
     * optional another customer object attached to the order.
     *
     * @return \App\Traits\Customer
     */
    public function getOther_customer()
    {
        return $this->other_customer;
    }

    /**
     * optional another customer object attached to the order.
     *
     * @param \App\Traits\Customer $other_customer
     */
    public function setOther_customer($other_customer)
    {
        $this->other_customer = $other_customer;
    }
    /**
     * a list of booking objects that this order contains
     *
     * @return \App\Traits\Booking[]
     */
    public function getBookings()
    {
        return $this->bookings;
    }

    /**
     * a list of booking objects that this order contains
     *
     * @param \App\Traits\Booking[] $bookings
     */
    public function setBookings($bookings)
    {
        $this->bookings = $bookings;
    }
    /**
     * the current status of the order
     *
     * @return string
     */
    public function getOrder_status()
    {
        return $this->order_status;
    }

    /**
     * the current status of the order
     *
     * @param string $order_status
     */
    public function setOrder_status($order_status)
    {
        $this->order_status = $order_status;
    }
    /**
     * the sum total on the order,
     *
     * @return double
     */
    public function getOrder_sum()
    {
        return $this->order_sum;
    }

    /**
     * the sum total on the order,
     *
     * @param double $order_sum
     */
    public function setOrder_sum($order_sum)
    {
        $this->order_sum = $order_sum;
    }
    /**
     * the outstanding amount to be paid on the order,
     *
     * @return double
     */
    public function getOrder_balance()
    {
        return $this->order_balance;
    }

    /**
     * the outstanding amount to be paid on the order,
     *
     * @param double $order_balance
     */
    public function setOrder_balance($order_balance)
    {
        $this->order_balance = $order_balance;
    }
    /**
     * list of payments done on the order
     *
     * @return \App\Traits\Payment[]
     */
    public function getPayments()
    {
        return $this->payments;
    }

    /**
     * list of payments done on the order
     *
     * @param \App\Traits\Payment[] $payments
     */
    public function setPayments($payments)
    {
        $this->payments = $payments;
    }
    /**
     * if invoiced, and enabled on the company, contains the ocr kid string created for the order
     *
     * @return string
     */
    public function getKid()
    {
        return $this->kid;
    }

    /**
     * if invoiced, and enabled on the company, contains the ocr kid string created for the order
     *
     * @param string $kid
     */
    public function setKid($kid)
    {
        $this->kid = $kid;
    }
    /**
     * related order, for creditnote
     *
     * @return integer
     */
    public function getRelated_order()
    {
        return $this->related_order;
    }

    /**
     * related order, for creditnote
     *
     * @param integer $related_order
     */
    public function setRelated_order($related_order)
    {
        $this->related_order = $related_order;
    }
    /**
     * SysStatus
     *
     * @return string
     */
    public function getSys_status()
    {
        return $this->sys_status;
    }

    /**
     * SysStatus
     *
     * @param string $sys_status
     */
    public function setSys_status($sys_status)
    {
        $this->sys_status = $sys_status;
    }
    /**
     * list of external booking references
     *
     * @return \App\Traits\ExternalBookingReference[]
     */
    public function getExternal_booking_references()
    {
        return $this->external_booking_references;
    }

    /**
     * list of external booking references
     *
     * @param \App\Traits\ExternalBookingReference[] $external_booking_references
     */
    public function setExternal_booking_references($external_booking_references)
    {
        $this->external_booking_references = $external_booking_references;
    }
    /**
     * UID
     *
     * @return integer
     */
    public function getOwner_id()
    {
        return $this->owner_id;
    }

    /**
     * UID
     *
     * @param integer $owner_id
     */
    public function setOwner_id($owner_id)
    {
        $this->owner_id = $owner_id;
    }
    /**
     * last changed by id
     *
     * @return integer
     */
    public function getChanged_id()
    {
        return $this->changed_id;
    }

    /**
     * last changed by id
     *
     * @param integer $changed_id
     */
    public function setChanged_id($changed_id)
    {
        $this->changed_id = $changed_id;
    }
    /**
     * Custom reference
     *
     * @return string
     */
    public function getCustom_reference()
    {
        return $this->custom_reference;
    }

    /**
     * Custom reference
     *
     * @param string $custom_reference
     */
    public function setCustom_reference($custom_reference)
    {
        $this->custom_reference = $custom_reference;
    }
    /**
     * checkout payment rule
     *
     * @return integer
     */
    public function getCheckout_payment_rule()
    {
        return $this->checkout_payment_rule;
    }

    /**
     * checkout payment rule
     *
     * @param integer $checkout_payment_rule
     */
    public function setCheckout_payment_rule($checkout_payment_rule)
    {
        $this->checkout_payment_rule = $checkout_payment_rule;
    }
    /**
     * checkout payment rule note
     *
     * @return string
     */
    public function getCheckout_payment_rule_note()
    {
        return $this->checkout_payment_rule_note;
    }

    /**
     * checkout payment rule note
     *
     * @param string $checkout_payment_rule_note
     */
    public function setCheckout_payment_rule_note($checkout_payment_rule_note)
    {
        $this->checkout_payment_rule_note = $checkout_payment_rule_note;
    }
    /**
     * internal_note
     *
     * @return string
     */
    public function getInternal_note()
    {
        return $this->internal_note;
    }

    /**
     * internal_note
     *
     * @param string $internal_note
     */
    public function setInternal_note($internal_note)
    {
        $this->internal_note = $internal_note;
    }

    /**
     * Initializes this Order from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of Order from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'order_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->order_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'company_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->company_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'invoice_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->invoice_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'multi_order_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->multi_order_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'invoice_date') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->invoice_date = $child;
            $happened = true;
        }
        else if (($xml->localName == 'due_date') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->due_date = $child;
            $happened = true;
        }
        else if (($xml->localName == 'payed_date') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->payed_date = $child;
            $happened = true;
        }
        else if (($xml->localName == 'cancel_date') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->cancel_date = $child;
            $happened = true;
        }
        else if (($xml->localName == 'changed_date') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->changed_date = $child;
            $happened = true;
        }
        else if (($xml->localName == 'registration_date') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->registration_date = $child;
            $happened = true;
        }
        else if (($xml->localName == 'customer') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\Customer($xml);
            $this->customer = $child;
            $happened = true;
        }
        else if (($xml->localName == 'arrival_customer') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\Customer($xml);
            $this->arrival_customer = $child;
            $happened = true;
        }
        else if (($xml->localName == 'other_customer') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\Customer($xml);
            $this->other_customer = $child;
            $happened = true;
        }
        else if (($xml->localName == 'bookings') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\Booking($xml);
            if (!isset($this->bookings)) {
                $this->bookings = array();
            }
            array_push($this->bookings, $child);
            $happened = true;
        }
        else if (($xml->localName == 'order_status') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->order_status = $child;
            $happened = true;
        }
        else if (($xml->localName == 'order_sum') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->order_sum = $child;
            $happened = true;
        }
        else if (($xml->localName == 'order_balance') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->order_balance = $child;
            $happened = true;
        }
        else if (($xml->localName == 'payments') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\Payment($xml);
            if (!isset($this->payments)) {
                $this->payments = array();
            }
            array_push($this->payments, $child);
            $happened = true;
        }
        else if (($xml->localName == 'kid') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->kid = $child;
            $happened = true;
        }
        else if (($xml->localName == 'related_order') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->related_order = $child;
            $happened = true;
        }
        else if (($xml->localName == 'sys_status') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->sys_status = $child;
            $happened = true;
        }
        else if (($xml->localName == 'external_booking_references') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\ExternalBookingReference($xml);
            if (!isset($this->external_booking_references)) {
                $this->external_booking_references = array();
            }
            array_push($this->external_booking_references, $child);
            $happened = true;
        }
        else if (($xml->localName == 'owner_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->owner_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'changed_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->changed_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'custom_reference') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->custom_reference = $child;
            $happened = true;
        }
        else if (($xml->localName == 'checkout_payment_rule') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->checkout_payment_rule = $child;
            $happened = true;
        }
        else if (($xml->localName == 'checkout_payment_rule_note') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->checkout_payment_rule_note = $child;
            $happened = true;
        }
        else if (($xml->localName == 'internal_note') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->internal_note = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of Order from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this Order to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->order_id) {
            $writer->startElementNs(null, 'order_id', null);
            $writer->text($this->order_id);
            $writer->endElement();
        }
        if ($this->company_id) {
            $writer->startElementNs(null, 'company_id', null);
            $writer->text($this->company_id);
            $writer->endElement();
        }
        if ($this->invoice_id) {
            $writer->startElementNs(null, 'invoice_id', null);
            $writer->text($this->invoice_id);
            $writer->endElement();
        }
        if ($this->multi_order_id) {
            $writer->startElementNs(null, 'multi_order_id', null);
            $writer->text($this->multi_order_id);
            $writer->endElement();
        }
        if ($this->invoice_date) {
            $writer->startElementNs(null, 'invoice_date', null);
            $writer->text($this->invoice_date);
            $writer->endElement();
        }
        if ($this->due_date) {
            $writer->startElementNs(null, 'due_date', null);
            $writer->text($this->due_date);
            $writer->endElement();
        }
        if ($this->payed_date) {
            $writer->startElementNs(null, 'payed_date', null);
            $writer->text($this->payed_date);
            $writer->endElement();
        }
        if ($this->cancel_date) {
            $writer->startElementNs(null, 'cancel_date', null);
            $writer->text($this->cancel_date);
            $writer->endElement();
        }
        if ($this->changed_date) {
            $writer->startElementNs(null, 'changed_date', null);
            $writer->text($this->changed_date);
            $writer->endElement();
        }
        if ($this->registration_date) {
            $writer->startElementNs(null, 'registration_date', null);
            $writer->text($this->registration_date);
            $writer->endElement();
        }
        if ($this->customer) {
            $writer->startElementNs(null, 'customer', null);
            $this->customer->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->arrival_customer) {
            $writer->startElementNs(null, 'arrival_customer', null);
            $this->arrival_customer->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->other_customer) {
            $writer->startElementNs(null, 'other_customer', null);
            $this->other_customer->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->bookings) {
            foreach ($this->bookings as $i => $x) {
                $writer->startElementNs(null, 'bookings', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->order_status) {
            $writer->startElementNs(null, 'order_status', null);
            $writer->text($this->order_status);
            $writer->endElement();
        }
        if ($this->order_sum) {
            $writer->startElementNs(null, 'order_sum', null);
            $writer->text($this->order_sum);
            $writer->endElement();
        }
        if ($this->order_balance) {
            $writer->startElementNs(null, 'order_balance', null);
            $writer->text($this->order_balance);
            $writer->endElement();
        }
        if ($this->payments) {
            foreach ($this->payments as $i => $x) {
                $writer->startElementNs(null, 'payments', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->kid) {
            $writer->startElementNs(null, 'kid', null);
            $writer->text($this->kid);
            $writer->endElement();
        }
        if ($this->related_order) {
            $writer->startElementNs(null, 'related_order', null);
            $writer->text($this->related_order);
            $writer->endElement();
        }
        if ($this->sys_status) {
            $writer->startElementNs(null, 'sys_status', null);
            $writer->text($this->sys_status);
            $writer->endElement();
        }
        if ($this->external_booking_references) {
            foreach ($this->external_booking_references as $i => $x) {
                $writer->startElementNs(null, 'external_booking_references', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->owner_id) {
            $writer->startElementNs(null, 'owner_id', null);
            $writer->text($this->owner_id);
            $writer->endElement();
        }
        if ($this->changed_id) {
            $writer->startElementNs(null, 'changed_id', null);
            $writer->text($this->changed_id);
            $writer->endElement();
        }
        if ($this->custom_reference) {
            $writer->startElementNs(null, 'custom_reference', null);
            $writer->text($this->custom_reference);
            $writer->endElement();
        }
        if ($this->checkout_payment_rule) {
            $writer->startElementNs(null, 'checkout_payment_rule', null);
            $writer->text($this->checkout_payment_rule);
            $writer->endElement();
        }
        if ($this->checkout_payment_rule_note) {
            $writer->startElementNs(null, 'checkout_payment_rule_note', null);
            $writer->text($this->checkout_payment_rule_note);
            $writer->endElement();
        }
        if ($this->internal_note) {
            $writer->startElementNs(null, 'internal_note', null);
            $writer->text($this->internal_note);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class OutOfOrderPeriod
{

    /**
     * the unique id of the out-of-order period
     *
     * @var integer
     */
    private $id;

    /**
     * The product id this out-of-order period belongs to, will always be set non-zero
     *
     * @var integer
     */
    private $product_id;

    /**
     * The unit_id this out-of-order period belongs to, will always be set non-zero
     *
     * @var integer
     */
    private $unit_id;

    /**
     * The product type this out-of-order period belongs to (will be either accommodation or activity)
     *
     * @var string
     */
    private $product_type;

    /**
     * The company_id this period belongs to
     *
     * @var integer
     */
    private $company_id;

    /**
     * the out of order period starts at this time
     *
     * @var integer
     */
    private $from;

    /**
     * the out of order period ends at this time
     *
     * @var integer
     */
    private $to;

    /**
     * Constructs a OutOfOrderPeriod from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * the unique id of the out-of-order period
     *
     * @return integer
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * the unique id of the out-of-order period
     *
     * @param integer $id
     */
    public function setId($id)
    {
        $this->id = $id;
    }
    /**
     * The product id this out-of-order period belongs to, will always be set non-zero
     *
     * @return integer
     */
    public function getProduct_id()
    {
        return $this->product_id;
    }

    /**
     * The product id this out-of-order period belongs to, will always be set non-zero
     *
     * @param integer $product_id
     */
    public function setProduct_id($product_id)
    {
        $this->product_id = $product_id;
    }
    /**
     * The unit_id this out-of-order period belongs to, will always be set non-zero
     *
     * @return integer
     */
    public function getUnit_id()
    {
        return $this->unit_id;
    }

    /**
     * The unit_id this out-of-order period belongs to, will always be set non-zero
     *
     * @param integer $unit_id
     */
    public function setUnit_id($unit_id)
    {
        $this->unit_id = $unit_id;
    }
    /**
     * The product type this out-of-order period belongs to (will be either accommodation or activity)
     *
     * @return string
     */
    public function getProduct_type()
    {
        return $this->product_type;
    }

    /**
     * The product type this out-of-order period belongs to (will be either accommodation or activity)
     *
     * @param string $product_type
     */
    public function setProduct_type($product_type)
    {
        $this->product_type = $product_type;
    }
    /**
     * The company_id this period belongs to
     *
     * @return integer
     */
    public function getCompany_id()
    {
        return $this->company_id;
    }

    /**
     * The company_id this period belongs to
     *
     * @param integer $company_id
     */
    public function setCompany_id($company_id)
    {
        $this->company_id = $company_id;
    }
    /**
     * the out of order period starts at this time
     *
     * @return integer
     */
    public function getFrom()
    {
        return $this->from;
    }

    /**
     * the out of order period starts at this time
     *
     * @param integer $from
     */
    public function setFrom($from)
    {
        $this->from = $from;
    }
    /**
     * the out of order period ends at this time
     *
     * @return integer
     */
    public function getTo()
    {
        return $this->to;
    }

    /**
     * the out of order period ends at this time
     *
     * @param integer $to
     */
    public function setTo($to)
    {
        $this->to = $to;
    }

    /**
     * Initializes this OutOfOrderPeriod from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of OutOfOrderPeriod from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'product_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->product_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'unit_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->unit_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'product_type') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->product_type = $child;
            $happened = true;
        }
        else if (($xml->localName == 'company_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->company_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'from') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->from = $child;
            $happened = true;
        }
        else if (($xml->localName == 'to') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->to = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of OutOfOrderPeriod from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this OutOfOrderPeriod to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->id) {
            $writer->startElementNs(null, 'id', null);
            $writer->text($this->id);
            $writer->endElement();
        }
        if ($this->product_id) {
            $writer->startElementNs(null, 'product_id', null);
            $writer->text($this->product_id);
            $writer->endElement();
        }
        if ($this->unit_id) {
            $writer->startElementNs(null, 'unit_id', null);
            $writer->text($this->unit_id);
            $writer->endElement();
        }
        if ($this->product_type) {
            $writer->startElementNs(null, 'product_type', null);
            $writer->text($this->product_type);
            $writer->endElement();
        }
        if ($this->company_id) {
            $writer->startElementNs(null, 'company_id', null);
            $writer->text($this->company_id);
            $writer->endElement();
        }
        if ($this->from) {
            $writer->startElementNs(null, 'from', null);
            $writer->text($this->from);
            $writer->endElement();
        }
        if ($this->to) {
            $writer->startElementNs(null, 'to', null);
            $writer->text($this->to);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class PaymentMethod
{

    /**
     * unique identifier, required field, Note that payment methods in different companies may have different id&#39;s even if the
     * creditCardType is the same, so don&#39;t mix PaymentMethods between companies.
     *
     * @var integer
     */
    private $id;

    /**
     * company identification id – required field
     *
     * @var integer
     */
    private $company_id;

    /**
     * descriptive name (not localized, in most cases, a payment method regarding creditcards is universally descriptive, eg “Visa”, “AmEx” etc...)
     *
     * @var string
     */
    private $name;

    /**
     * enum describing the Credit Card Type, see creditCardType
     *
     * @var string
     */
    private $creditcard_type;

    /**
     * integrator id
     *
     * @var integer
     */
    private $integrator_id;

    /**
     * Constructs a PaymentMethod from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * unique identifier, required field, Note that payment methods in different companies may have different id&#39;s even if the
       * creditCardType is the same, so don&#39;t mix PaymentMethods between companies.
     *
     * @return integer
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * unique identifier, required field, Note that payment methods in different companies may have different id&#39;s even if the
       * creditCardType is the same, so don&#39;t mix PaymentMethods between companies.
     *
     * @param integer $id
     */
    public function setId($id)
    {
        $this->id = $id;
    }
    /**
     * company identification id – required field
     *
     * @return integer
     */
    public function getCompany_id()
    {
        return $this->company_id;
    }

    /**
     * company identification id – required field
     *
     * @param integer $company_id
     */
    public function setCompany_id($company_id)
    {
        $this->company_id = $company_id;
    }
    /**
     * descriptive name (not localized, in most cases, a payment method regarding creditcards is universally descriptive, eg “Visa”, “AmEx” etc...)
     *
     * @return string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * descriptive name (not localized, in most cases, a payment method regarding creditcards is universally descriptive, eg “Visa”, “AmEx” etc...)
     *
     * @param string $name
     */
    public function setName($name)
    {
        $this->name = $name;
    }
    /**
     * enum describing the Credit Card Type, see creditCardType
     *
     * @return string
     */
    public function getCreditcard_type()
    {
        return $this->creditcard_type;
    }

    /**
     * enum describing the Credit Card Type, see creditCardType
     *
     * @param string $creditcard_type
     */
    public function setCreditcard_type($creditcard_type)
    {
        $this->creditcard_type = $creditcard_type;
    }
    /**
     * integrator id
     *
     * @return integer
     */
    public function getIntegrator_id()
    {
        return $this->integrator_id;
    }

    /**
     * integrator id
     *
     * @param integer $integrator_id
     */
    public function setIntegrator_id($integrator_id)
    {
        $this->integrator_id = $integrator_id;
    }

    /**
     * Initializes this PaymentMethod from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of PaymentMethod from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'company_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->company_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'name') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->name = $child;
            $happened = true;
        }
        else if (($xml->localName == 'creditcard_type') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->creditcard_type = $child;
            $happened = true;
        }
        else if (($xml->localName == 'integrator_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->integrator_id = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of PaymentMethod from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this PaymentMethod to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->id) {
            $writer->startElementNs(null, 'id', null);
            $writer->text($this->id);
            $writer->endElement();
        }
        if ($this->company_id) {
            $writer->startElementNs(null, 'company_id', null);
            $writer->text($this->company_id);
            $writer->endElement();
        }
        if ($this->name) {
            $writer->startElementNs(null, 'name', null);
            $writer->text($this->name);
            $writer->endElement();
        }
        if ($this->creditcard_type) {
            $writer->startElementNs(null, 'creditcard_type', null);
            $writer->text($this->creditcard_type);
            $writer->endElement();
        }
        if ($this->integrator_id) {
            $writer->startElementNs(null, 'integrator_id', null);
            $writer->text($this->integrator_id);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class Price
{

    /**
     * unique id of the price, if productType is something other than accommodation (or activities, with new price system), the id may be ignored since those types will only have one available price type.
     *
     * please note: This may be set to 0 when calling change_order / change_booking to make the system pick up price changes where there is no need to track the original booked price id.
     * (in that case, ensure that group_id is set to a valid group id (same or different) )
     *
     * @var integer
     */
    private $price_id;

    /**
     * specifies the grouping id this price belongs to, if price_id is 0, this needs to be set in store_order/change_ordrer|booking
     *
     * @var integer
     */
    private $group_id;

    /**
     * may contain a reference to which product object this price is related to
     *
     * @var \App\Traits\Product
     */
    private $product;

    /**
     * textual name of the price object
     *
     * @var string
     */
    private $price_name;

    /**
     * the price value (always in the company currency), Can also be set to specific override any calculations in store_price/change_order/change_booking
     *
     * @var double
     */
    private $price_value;

    /**
     * boolean value indicating if the price is recurring or not (one-time)
     *
     * @var boolean
     */
    private $recurring;

    /**
     * the price is valid from this timestamp
     *
     * @var integer
     */
    private $from;

    /**
     * time the price is valid until this timestamp
     *
     * @var integer
     */
    private $to;

    /**
     * list of priceday objects, contains price information defined for daystepping, see PriceDay object for deeper explanation
     *
     * @var \App\Traits\PriceDay[]
     */
    private $daystep_prices;

    /**
     * value for persons limit1
     *
     * @var integer
     */
    private $persons_limit1;

    /**
     * Operator value for the persons_limit1 value
     *
     * @var string
     */
    private $persons_limit1_operator;

    /**
     * value for persons limit2
     *
     * @var integer
     */
    private $persons_limit2;

    /**
     * Operator value for the persons_limit2 value
     *
     * @var string
     */
    private $persons_limit2_operator;

    /**
     * value for days limit1
     *
     * @var integer
     */
    private $days_limit1;

    /**
     * Operator value for the days_limit1 value
     *
     * @var string
     */
    private $days_limit1_operator;

    /**
     * value for days limit2
     *
     * @var integer
     */
    private $days_limit2;

    /**
     * Operator value for the days_limit2 value
     *
     * @var string
     */
    private $days_limit2_operator;

    /**
     * Price type
     *
     * @var string
     */
    private $price_type;

    /**
     * related guest type
     *
     * @var integer
     */
    private $guest_type;

    /**
     * Constructs a Price from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * unique id of the price, if productType is something other than accommodation (or activities, with new price system), the id may be ignored since those types will only have one available price type.
       *
       * please note: This may be set to 0 when calling change_order / change_booking to make the system pick up price changes where there is no need to track the original booked price id.
       * (in that case, ensure that group_id is set to a valid group id (same or different) )
     *
     * @return integer
     */
    public function getPrice_id()
    {
        return $this->price_id;
    }

    /**
     * unique id of the price, if productType is something other than accommodation (or activities, with new price system), the id may be ignored since those types will only have one available price type.
       *
       * please note: This may be set to 0 when calling change_order / change_booking to make the system pick up price changes where there is no need to track the original booked price id.
       * (in that case, ensure that group_id is set to a valid group id (same or different) )
     *
     * @param integer $price_id
     */
    public function setPrice_id($price_id)
    {
        $this->price_id = $price_id;
    }
    /**
     * specifies the grouping id this price belongs to, if price_id is 0, this needs to be set in store_order/change_ordrer|booking
     *
     * @return integer
     */
    public function getGroup_id()
    {
        return $this->group_id;
    }

    /**
     * specifies the grouping id this price belongs to, if price_id is 0, this needs to be set in store_order/change_ordrer|booking
     *
     * @param integer $group_id
     */
    public function setGroup_id($group_id)
    {
        $this->group_id = $group_id;
    }
    /**
     * may contain a reference to which product object this price is related to
     *
     * @return \App\Traits\Product
     */
    public function getProduct()
    {
        return $this->product;
    }

    /**
     * may contain a reference to which product object this price is related to
     *
     * @param \App\Traits\Product $product
     */
    public function setProduct($product)
    {
        $this->product = $product;
    }
    /**
     * textual name of the price object
     *
     * @return string
     */
    public function getPrice_name()
    {
        return $this->price_name;
    }

    /**
     * textual name of the price object
     *
     * @param string $price_name
     */
    public function setPrice_name($price_name)
    {
        $this->price_name = $price_name;
    }
    /**
     * the price value (always in the company currency), Can also be set to specific override any calculations in store_price/change_order/change_booking
     *
     * @return double
     */
    public function getPrice_value()
    {
        return $this->price_value;
    }

    /**
     * the price value (always in the company currency), Can also be set to specific override any calculations in store_price/change_order/change_booking
     *
     * @param double $price_value
     */
    public function setPrice_value($price_value)
    {
        $this->price_value = $price_value;
    }
    /**
     * boolean value indicating if the price is recurring or not (one-time)
     *
     * @return boolean
     */
    public function getRecurring()
    {
        return $this->recurring;
    }

    /**
     * boolean value indicating if the price is recurring or not (one-time)
     *
     * @param boolean $recurring
     */
    public function setRecurring($recurring)
    {
        $this->recurring = $recurring;
    }
    /**
     * the price is valid from this timestamp
     *
     * @return integer
     */
    public function getFrom()
    {
        return $this->from;
    }

    /**
     * the price is valid from this timestamp
     *
     * @param integer $from
     */
    public function setFrom($from)
    {
        $this->from = $from;
    }
    /**
     * time the price is valid until this timestamp
     *
     * @return integer
     */
    public function getTo()
    {
        return $this->to;
    }

    /**
     * time the price is valid until this timestamp
     *
     * @param integer $to
     */
    public function setTo($to)
    {
        $this->to = $to;
    }
    /**
     * list of priceday objects, contains price information defined for daystepping, see PriceDay object for deeper explanation
     *
     * @return \App\Traits\PriceDay[]
     */
    public function getDaystep_prices()
    {
        return $this->daystep_prices;
    }

    /**
     * list of priceday objects, contains price information defined for daystepping, see PriceDay object for deeper explanation
     *
     * @param \App\Traits\PriceDay[] $daystep_prices
     */
    public function setDaystep_prices($daystep_prices)
    {
        $this->daystep_prices = $daystep_prices;
    }
    /**
     * value for persons limit1
     *
     * @return integer
     */
    public function getPersons_limit1()
    {
        return $this->persons_limit1;
    }

    /**
     * value for persons limit1
     *
     * @param integer $persons_limit1
     */
    public function setPersons_limit1($persons_limit1)
    {
        $this->persons_limit1 = $persons_limit1;
    }
    /**
     * Operator value for the persons_limit1 value
     *
     * @return string
     */
    public function getPersons_limit1_operator()
    {
        return $this->persons_limit1_operator;
    }

    /**
     * Operator value for the persons_limit1 value
     *
     * @param string $persons_limit1_operator
     */
    public function setPersons_limit1_operator($persons_limit1_operator)
    {
        $this->persons_limit1_operator = $persons_limit1_operator;
    }
    /**
     * value for persons limit2
     *
     * @return integer
     */
    public function getPersons_limit2()
    {
        return $this->persons_limit2;
    }

    /**
     * value for persons limit2
     *
     * @param integer $persons_limit2
     */
    public function setPersons_limit2($persons_limit2)
    {
        $this->persons_limit2 = $persons_limit2;
    }
    /**
     * Operator value for the persons_limit2 value
     *
     * @return string
     */
    public function getPersons_limit2_operator()
    {
        return $this->persons_limit2_operator;
    }

    /**
     * Operator value for the persons_limit2 value
     *
     * @param string $persons_limit2_operator
     */
    public function setPersons_limit2_operator($persons_limit2_operator)
    {
        $this->persons_limit2_operator = $persons_limit2_operator;
    }
    /**
     * value for days limit1
     *
     * @return integer
     */
    public function getDays_limit1()
    {
        return $this->days_limit1;
    }

    /**
     * value for days limit1
     *
     * @param integer $days_limit1
     */
    public function setDays_limit1($days_limit1)
    {
        $this->days_limit1 = $days_limit1;
    }
    /**
     * Operator value for the days_limit1 value
     *
     * @return string
     */
    public function getDays_limit1_operator()
    {
        return $this->days_limit1_operator;
    }

    /**
     * Operator value for the days_limit1 value
     *
     * @param string $days_limit1_operator
     */
    public function setDays_limit1_operator($days_limit1_operator)
    {
        $this->days_limit1_operator = $days_limit1_operator;
    }
    /**
     * value for days limit2
     *
     * @return integer
     */
    public function getDays_limit2()
    {
        return $this->days_limit2;
    }

    /**
     * value for days limit2
     *
     * @param integer $days_limit2
     */
    public function setDays_limit2($days_limit2)
    {
        $this->days_limit2 = $days_limit2;
    }
    /**
     * Operator value for the days_limit2 value
     *
     * @return string
     */
    public function getDays_limit2_operator()
    {
        return $this->days_limit2_operator;
    }

    /**
     * Operator value for the days_limit2 value
     *
     * @param string $days_limit2_operator
     */
    public function setDays_limit2_operator($days_limit2_operator)
    {
        $this->days_limit2_operator = $days_limit2_operator;
    }
    /**
     * Price type
     *
     * @return string
     */
    public function getPrice_type()
    {
        return $this->price_type;
    }

    /**
     * Price type
     *
     * @param string $price_type
     */
    public function setPrice_type($price_type)
    {
        $this->price_type = $price_type;
    }
    /**
     * related guest type
     *
     * @return integer
     */
    public function getGuest_type()
    {
        return $this->guest_type;
    }

    /**
     * related guest type
     *
     * @param integer $guest_type
     */
    public function setGuest_type($guest_type)
    {
        $this->guest_type = $guest_type;
    }

    /**
     * Initializes this Price from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of Price from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'price_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->price_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'group_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->group_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'product') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\Product($xml);
            $this->product = $child;
            $happened = true;
        }
        else if (($xml->localName == 'price_name') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->price_name = $child;
            $happened = true;
        }
        else if (($xml->localName == 'price_value') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->price_value = $child;
            $happened = true;
        }
        else if (($xml->localName == 'recurring') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->recurring = $child;
            $happened = true;
        }
        else if (($xml->localName == 'from') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->from = $child;
            $happened = true;
        }
        else if (($xml->localName == 'to') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->to = $child;
            $happened = true;
        }
        else if (($xml->localName == 'daystep_prices') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\PriceDay($xml);
            if (!isset($this->daystep_prices)) {
                $this->daystep_prices = array();
            }
            array_push($this->daystep_prices, $child);
            $happened = true;
        }
        else if (($xml->localName == 'persons_limit1') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->persons_limit1 = $child;
            $happened = true;
        }
        else if (($xml->localName == 'persons_limit1_operator') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->persons_limit1_operator = $child;
            $happened = true;
        }
        else if (($xml->localName == 'persons_limit2') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->persons_limit2 = $child;
            $happened = true;
        }
        else if (($xml->localName == 'persons_limit2_operator') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->persons_limit2_operator = $child;
            $happened = true;
        }
        else if (($xml->localName == 'days_limit1') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->days_limit1 = $child;
            $happened = true;
        }
        else if (($xml->localName == 'days_limit1_operator') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->days_limit1_operator = $child;
            $happened = true;
        }
        else if (($xml->localName == 'days_limit2') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->days_limit2 = $child;
            $happened = true;
        }
        else if (($xml->localName == 'days_limit2_operator') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->days_limit2_operator = $child;
            $happened = true;
        }
        else if (($xml->localName == 'price_type') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->price_type = $child;
            $happened = true;
        }
        else if (($xml->localName == 'guest_type') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->guest_type = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of Price from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this Price to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->price_id) {
            $writer->startElementNs(null, 'price_id', null);
            $writer->text($this->price_id);
            $writer->endElement();
        }
        if ($this->group_id) {
            $writer->startElementNs(null, 'group_id', null);
            $writer->text($this->group_id);
            $writer->endElement();
        }
        if ($this->product) {
            $writer->startElementNs(null, 'product', null);
            $this->product->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->price_name) {
            $writer->startElementNs(null, 'price_name', null);
            $writer->text($this->price_name);
            $writer->endElement();
        }
        if ($this->price_value) {
            $writer->startElementNs(null, 'price_value', null);
            $writer->text($this->price_value);
            $writer->endElement();
        }
        if ($this->recurring) {
            $writer->startElementNs(null, 'recurring', null);
            $writer->text($this->recurring);
            $writer->endElement();
        }
        if ($this->from) {
            $writer->startElementNs(null, 'from', null);
            $writer->text($this->from);
            $writer->endElement();
        }
        if ($this->to) {
            $writer->startElementNs(null, 'to', null);
            $writer->text($this->to);
            $writer->endElement();
        }
        if ($this->daystep_prices) {
            foreach ($this->daystep_prices as $i => $x) {
                $writer->startElementNs(null, 'daystep_prices', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->persons_limit1) {
            $writer->startElementNs(null, 'persons_limit1', null);
            $writer->text($this->persons_limit1);
            $writer->endElement();
        }
        if ($this->persons_limit1_operator) {
            $writer->startElementNs(null, 'persons_limit1_operator', null);
            $writer->text($this->persons_limit1_operator);
            $writer->endElement();
        }
        if ($this->persons_limit2) {
            $writer->startElementNs(null, 'persons_limit2', null);
            $writer->text($this->persons_limit2);
            $writer->endElement();
        }
        if ($this->persons_limit2_operator) {
            $writer->startElementNs(null, 'persons_limit2_operator', null);
            $writer->text($this->persons_limit2_operator);
            $writer->endElement();
        }
        if ($this->days_limit1) {
            $writer->startElementNs(null, 'days_limit1', null);
            $writer->text($this->days_limit1);
            $writer->endElement();
        }
        if ($this->days_limit1_operator) {
            $writer->startElementNs(null, 'days_limit1_operator', null);
            $writer->text($this->days_limit1_operator);
            $writer->endElement();
        }
        if ($this->days_limit2) {
            $writer->startElementNs(null, 'days_limit2', null);
            $writer->text($this->days_limit2);
            $writer->endElement();
        }
        if ($this->days_limit2_operator) {
            $writer->startElementNs(null, 'days_limit2_operator', null);
            $writer->text($this->days_limit2_operator);
            $writer->endElement();
        }
        if ($this->price_type) {
            $writer->startElementNs(null, 'price_type', null);
            $writer->text($this->price_type);
            $writer->endElement();
        }
        if ($this->guest_type) {
            $writer->startElementNs(null, 'guest_type', null);
            $writer->text($this->guest_type);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class PriceGroup
{

    /**
     * company unique id for the grouping object, referenced in Price.group_id
     *
     * @var integer
     */
    private $id;

    /**
     * company_id
     *
     * @var integer
     */
    private $company_id;

    /**
     * Price group name
     *
     * @var string
     */
    private $name;

    /**
     * product_id that this group belongs to
     *
     * @var integer
     */
    private $product_id;

    /**
     * Price template for this group, will be used when creating new prices.
     *
     * @var \App\Traits\Price
     */
    private $template;

    /**
     * Product type for this price group
     *
     * @var string
     */
    private $product_type;

    /**
     * Constructs a PriceGroup from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * company unique id for the grouping object, referenced in Price.group_id
     *
     * @return integer
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * company unique id for the grouping object, referenced in Price.group_id
     *
     * @param integer $id
     */
    public function setId($id)
    {
        $this->id = $id;
    }
    /**
     * company_id
     *
     * @return integer
     */
    public function getCompany_id()
    {
        return $this->company_id;
    }

    /**
     * company_id
     *
     * @param integer $company_id
     */
    public function setCompany_id($company_id)
    {
        $this->company_id = $company_id;
    }
    /**
     * Price group name
     *
     * @return string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * Price group name
     *
     * @param string $name
     */
    public function setName($name)
    {
        $this->name = $name;
    }
    /**
     * product_id that this group belongs to
     *
     * @return integer
     */
    public function getProduct_id()
    {
        return $this->product_id;
    }

    /**
     * product_id that this group belongs to
     *
     * @param integer $product_id
     */
    public function setProduct_id($product_id)
    {
        $this->product_id = $product_id;
    }
    /**
     * Price template for this group, will be used when creating new prices.
     *
     * @return \App\Traits\Price
     */
    public function getTemplate()
    {
        return $this->template;
    }

    /**
     * Price template for this group, will be used when creating new prices.
     *
     * @param \App\Traits\Price $template
     */
    public function setTemplate($template)
    {
        $this->template = $template;
    }
    /**
     * Product type for this price group
     *
     * @return string
     */
    public function getProduct_type()
    {
        return $this->product_type;
    }

    /**
     * Product type for this price group
     *
     * @param string $product_type
     */
    public function setProduct_type($product_type)
    {
        $this->product_type = $product_type;
    }

    /**
     * Initializes this PriceGroup from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of PriceGroup from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'company_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->company_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'name') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->name = $child;
            $happened = true;
        }
        else if (($xml->localName == 'product_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->product_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'template') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\Price($xml);
            $this->template = $child;
            $happened = true;
        }
        else if (($xml->localName == 'product_type') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->product_type = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of PriceGroup from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this PriceGroup to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->id) {
            $writer->startElementNs(null, 'id', null);
            $writer->text($this->id);
            $writer->endElement();
        }
        if ($this->company_id) {
            $writer->startElementNs(null, 'company_id', null);
            $writer->text($this->company_id);
            $writer->endElement();
        }
        if ($this->name) {
            $writer->startElementNs(null, 'name', null);
            $writer->text($this->name);
            $writer->endElement();
        }
        if ($this->product_id) {
            $writer->startElementNs(null, 'product_id', null);
            $writer->text($this->product_id);
            $writer->endElement();
        }
        if ($this->template) {
            $writer->startElementNs(null, 'template', null);
            $this->template->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->product_type) {
            $writer->startElementNs(null, 'product_type', null);
            $writer->text($this->product_type);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class Product
{

    /**
     * unique identificator for the specified product type
     *
     * @var integer
     */
    private $product_id;

    /**
     * if non zero, indicates that this is a specified unit
     *
     * @var integer
     */
    private $unit_id;

    /**
     * The type of product
     *
     * @var string
     */
    private $product_type;

    /**
     * unique company id to specify which company the product belongs to
     *
     * @var integer
     */
    private $company_id;

    /**
     * list of attribute objects assigned to this product, if any
     *
     * @var \App\Traits\Attribute[]
     */
    private $attributes;

    /**
     * the descriptive name of the product, f.ex. “Doubleroom”
     *
     * @var string
     */
    private $product_name;

    /**
     * indicates the unit name if this is a specific unit, f.ex. “Room 110”
     *
     * @var string
     */
    private $unit_name;

    /**
     * 2-char language code requested for attributes and product name
     *
     * @var string
     */
    private $language;

    /**
     * In conjuction with a GeoQuery, indicates the distance inside the search radius from the requested position
     *
     * @var double
     */
    private $distance;

    /**
     * Set number of available units in operation find_available_price, or total number of units per product in operation find_products
     *
     * @var integer
     */
    private $available;

    /**
     * optional flag indicating if the product has a cleaned state, provided in
     * get_cleaning_list, and used by save_cleaned_state functions only
     *
     * @var boolean
     */
    private $cleaned;

    /**
     * minimum number to order (product is required) used in related services
     *
     * @var integer
     */
    private $order_min;

    /**
     * maximum number to order (product is limited) used in related services
     *
     * @var integer
     */
    private $order_max;

    /**
     * may be set to indicate if product is grouped somehow (f.ex. hostel beds) rarely used
     *
     * @var integer
     */
    private $group_id;

    /**
     * may be provided to indicate a special role. used in special cases.
     *
     * @var integer
     */
    private $role_id;

    /**
     * if configured in the hotel, indicates a numeric room number
     *
     * @var integer
     */
    private $room_number;

    /**
     * (optional) set if product belongs to a specific department id.
     *
     * @var integer
     */
    private $department_id;

    /**
     * (optional) on units, there may exist an external reference (external system id)
     *
     * @var string
     */
    private $external_reference;

    /**
     * Constructs a Product from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * unique identificator for the specified product type
     *
     * @return integer
     */
    public function getProduct_id()
    {
        return $this->product_id;
    }

    /**
     * unique identificator for the specified product type
     *
     * @param integer $product_id
     */
    public function setProduct_id($product_id)
    {
        $this->product_id = $product_id;
    }
    /**
     * if non zero, indicates that this is a specified unit
     *
     * @return integer
     */
    public function getUnit_id()
    {
        return $this->unit_id;
    }

    /**
     * if non zero, indicates that this is a specified unit
     *
     * @param integer $unit_id
     */
    public function setUnit_id($unit_id)
    {
        $this->unit_id = $unit_id;
    }
    /**
     * The type of product
     *
     * @return string
     */
    public function getProduct_type()
    {
        return $this->product_type;
    }

    /**
     * The type of product
     *
     * @param string $product_type
     */
    public function setProduct_type($product_type)
    {
        $this->product_type = $product_type;
    }
    /**
     * unique company id to specify which company the product belongs to
     *
     * @return integer
     */
    public function getCompany_id()
    {
        return $this->company_id;
    }

    /**
     * unique company id to specify which company the product belongs to
     *
     * @param integer $company_id
     */
    public function setCompany_id($company_id)
    {
        $this->company_id = $company_id;
    }
    /**
     * list of attribute objects assigned to this product, if any
     *
     * @return \App\Traits\Attribute[]
     */
    public function getAttributes()
    {
        return $this->attributes;
    }

    /**
     * list of attribute objects assigned to this product, if any
     *
     * @param \App\Traits\Attribute[] $attributes
     */
    public function setAttributes($attributes)
    {
        $this->attributes = $attributes;
    }
    /**
     * the descriptive name of the product, f.ex. “Doubleroom”
     *
     * @return string
     */
    public function getProduct_name()
    {
        return $this->product_name;
    }

    /**
     * the descriptive name of the product, f.ex. “Doubleroom”
     *
     * @param string $product_name
     */
    public function setProduct_name($product_name)
    {
        $this->product_name = $product_name;
    }
    /**
     * indicates the unit name if this is a specific unit, f.ex. “Room 110”
     *
     * @return string
     */
    public function getUnit_name()
    {
        return $this->unit_name;
    }

    /**
     * indicates the unit name if this is a specific unit, f.ex. “Room 110”
     *
     * @param string $unit_name
     */
    public function setUnit_name($unit_name)
    {
        $this->unit_name = $unit_name;
    }
    /**
     * 2-char language code requested for attributes and product name
     *
     * @return string
     */
    public function getLanguage()
    {
        return $this->language;
    }

    /**
     * 2-char language code requested for attributes and product name
     *
     * @param string $language
     */
    public function setLanguage($language)
    {
        $this->language = $language;
    }
    /**
     * In conjuction with a GeoQuery, indicates the distance inside the search radius from the requested position
     *
     * @return double
     */
    public function getDistance()
    {
        return $this->distance;
    }

    /**
     * In conjuction with a GeoQuery, indicates the distance inside the search radius from the requested position
     *
     * @param double $distance
     */
    public function setDistance($distance)
    {
        $this->distance = $distance;
    }
    /**
     * Set number of available units in operation find_available_price, or total number of units per product in operation find_products
     *
     * @return integer
     */
    public function getAvailable()
    {
        return $this->available;
    }

    /**
     * Set number of available units in operation find_available_price, or total number of units per product in operation find_products
     *
     * @param integer $available
     */
    public function setAvailable($available)
    {
        $this->available = $available;
    }
    /**
     * optional flag indicating if the product has a cleaned state, provided in
       * get_cleaning_list, and used by save_cleaned_state functions only
     *
     * @return boolean
     */
    public function getCleaned()
    {
        return $this->cleaned;
    }

    /**
     * optional flag indicating if the product has a cleaned state, provided in
       * get_cleaning_list, and used by save_cleaned_state functions only
     *
     * @param boolean $cleaned
     */
    public function setCleaned($cleaned)
    {
        $this->cleaned = $cleaned;
    }
    /**
     * minimum number to order (product is required) used in related services
     *
     * @return integer
     */
    public function getOrder_min()
    {
        return $this->order_min;
    }

    /**
     * minimum number to order (product is required) used in related services
     *
     * @param integer $order_min
     */
    public function setOrder_min($order_min)
    {
        $this->order_min = $order_min;
    }
    /**
     * maximum number to order (product is limited) used in related services
     *
     * @return integer
     */
    public function getOrder_max()
    {
        return $this->order_max;
    }

    /**
     * maximum number to order (product is limited) used in related services
     *
     * @param integer $order_max
     */
    public function setOrder_max($order_max)
    {
        $this->order_max = $order_max;
    }
    /**
     * may be set to indicate if product is grouped somehow (f.ex. hostel beds) rarely used
     *
     * @return integer
     */
    public function getGroup_id()
    {
        return $this->group_id;
    }

    /**
     * may be set to indicate if product is grouped somehow (f.ex. hostel beds) rarely used
     *
     * @param integer $group_id
     */
    public function setGroup_id($group_id)
    {
        $this->group_id = $group_id;
    }
    /**
     * may be provided to indicate a special role. used in special cases.
     *
     * @return integer
     */
    public function getRole_id()
    {
        return $this->role_id;
    }

    /**
     * may be provided to indicate a special role. used in special cases.
     *
     * @param integer $role_id
     */
    public function setRole_id($role_id)
    {
        $this->role_id = $role_id;
    }
    /**
     * if configured in the hotel, indicates a numeric room number
     *
     * @return integer
     */
    public function getRoom_number()
    {
        return $this->room_number;
    }

    /**
     * if configured in the hotel, indicates a numeric room number
     *
     * @param integer $room_number
     */
    public function setRoom_number($room_number)
    {
        $this->room_number = $room_number;
    }
    /**
     * (optional) set if product belongs to a specific department id.
     *
     * @return integer
     */
    public function getDepartment_id()
    {
        return $this->department_id;
    }

    /**
     * (optional) set if product belongs to a specific department id.
     *
     * @param integer $department_id
     */
    public function setDepartment_id($department_id)
    {
        $this->department_id = $department_id;
    }
    /**
     * (optional) on units, there may exist an external reference (external system id)
     *
     * @return string
     */
    public function getExternal_reference()
    {
        return $this->external_reference;
    }

    /**
     * (optional) on units, there may exist an external reference (external system id)
     *
     * @param string $external_reference
     */
    public function setExternal_reference($external_reference)
    {
        $this->external_reference = $external_reference;
    }

    /**
     * Initializes this Product from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of Product from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'product_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->product_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'unit_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->unit_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'product_type') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->product_type = $child;
            $happened = true;
        }
        else if (($xml->localName == 'company_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->company_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'attributes') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\Attribute($xml);
            if (!isset($this->attributes)) {
                $this->attributes = array();
            }
            array_push($this->attributes, $child);
            $happened = true;
        }
        else if (($xml->localName == 'product_name') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->product_name = $child;
            $happened = true;
        }
        else if (($xml->localName == 'unit_name') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->unit_name = $child;
            $happened = true;
        }
        else if (($xml->localName == 'language') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->language = $child;
            $happened = true;
        }
        else if (($xml->localName == 'distance') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->distance = $child;
            $happened = true;
        }
        else if (($xml->localName == 'available') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->available = $child;
            $happened = true;
        }
        else if (($xml->localName == 'cleaned') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->cleaned = $child;
            $happened = true;
        }
        else if (($xml->localName == 'order_min') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->order_min = $child;
            $happened = true;
        }
        else if (($xml->localName == 'order_max') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->order_max = $child;
            $happened = true;
        }
        else if (($xml->localName == 'group_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->group_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'role_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->role_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'room_number') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->room_number = $child;
            $happened = true;
        }
        else if (($xml->localName == 'department_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->department_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'external_reference') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->external_reference = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of Product from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this Product to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->product_id) {
            $writer->startElementNs(null, 'product_id', null);
            $writer->text($this->product_id);
            $writer->endElement();
        }
        if ($this->unit_id) {
            $writer->startElementNs(null, 'unit_id', null);
            $writer->text($this->unit_id);
            $writer->endElement();
        }
        if ($this->product_type) {
            $writer->startElementNs(null, 'product_type', null);
            $writer->text($this->product_type);
            $writer->endElement();
        }
        if ($this->company_id) {
            $writer->startElementNs(null, 'company_id', null);
            $writer->text($this->company_id);
            $writer->endElement();
        }
        if ($this->attributes) {
            foreach ($this->attributes as $i => $x) {
                $writer->startElementNs(null, 'attributes', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->product_name) {
            $writer->startElementNs(null, 'product_name', null);
            $writer->text($this->product_name);
            $writer->endElement();
        }
        if ($this->unit_name) {
            $writer->startElementNs(null, 'unit_name', null);
            $writer->text($this->unit_name);
            $writer->endElement();
        }
        if ($this->language) {
            $writer->startElementNs(null, 'language', null);
            $writer->text($this->language);
            $writer->endElement();
        }
        if ($this->distance) {
            $writer->startElementNs(null, 'distance', null);
            $writer->text($this->distance);
            $writer->endElement();
        }
        if ($this->available) {
            $writer->startElementNs(null, 'available', null);
            $writer->text($this->available);
            $writer->endElement();
        }
        if ($this->cleaned) {
            $writer->startElementNs(null, 'cleaned', null);
            $writer->text($this->cleaned);
            $writer->endElement();
        }
        if ($this->order_min) {
            $writer->startElementNs(null, 'order_min', null);
            $writer->text($this->order_min);
            $writer->endElement();
        }
        if ($this->order_max) {
            $writer->startElementNs(null, 'order_max', null);
            $writer->text($this->order_max);
            $writer->endElement();
        }
        if ($this->group_id) {
            $writer->startElementNs(null, 'group_id', null);
            $writer->text($this->group_id);
            $writer->endElement();
        }
        if ($this->role_id) {
            $writer->startElementNs(null, 'role_id', null);
            $writer->text($this->role_id);
            $writer->endElement();
        }
        if ($this->room_number) {
            $writer->startElementNs(null, 'room_number', null);
            $writer->text($this->room_number);
            $writer->endElement();
        }
        if ($this->department_id) {
            $writer->startElementNs(null, 'department_id', null);
            $writer->text($this->department_id);
            $writer->endElement();
        }
        if ($this->external_reference) {
            $writer->startElementNs(null, 'external_reference', null);
            $writer->text($this->external_reference);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class ProductAvailability
{

    /**
     * associated product for the availability information
     *
     * @var \App\Traits\Product
     */
    private $product;

    /**
     * List of availability range descriptions
     *
     * @var \App\Traits\ProductAvailabilityRange[]
     */
    private $availability;

    /**
     * If set, and non zero, this availability is valid for this price group id only
     *
     * @var integer
     */
    private $price_group_id;

    /**
     * Constructs a ProductAvailability from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * associated product for the availability information
     *
     * @return \App\Traits\Product
     */
    public function getProduct()
    {
        return $this->product;
    }

    /**
     * associated product for the availability information
     *
     * @param \App\Traits\Product $product
     */
    public function setProduct($product)
    {
        $this->product = $product;
    }
    /**
     * List of availability range descriptions
     *
     * @return \App\Traits\ProductAvailabilityRange[]
     */
    public function getAvailability()
    {
        return $this->availability;
    }

    /**
     * List of availability range descriptions
     *
     * @param \App\Traits\ProductAvailabilityRange[] $availability
     */
    public function setAvailability($availability)
    {
        $this->availability = $availability;
    }
    /**
     * If set, and non zero, this availability is valid for this price group id only
     *
     * @return integer
     */
    public function getPrice_group_id()
    {
        return $this->price_group_id;
    }

    /**
     * If set, and non zero, this availability is valid for this price group id only
     *
     * @param integer $price_group_id
     */
    public function setPrice_group_id($price_group_id)
    {
        $this->price_group_id = $price_group_id;
    }

    /**
     * Initializes this ProductAvailability from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of ProductAvailability from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'product') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\Product($xml);
            $this->product = $child;
            $happened = true;
        }
        else if (($xml->localName == 'availability') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\ProductAvailabilityRange($xml);
            if (!isset($this->availability)) {
                $this->availability = array();
            }
            array_push($this->availability, $child);
            $happened = true;
        }
        else if (($xml->localName == 'price_group_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->price_group_id = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of ProductAvailability from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this ProductAvailability to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->product) {
            $writer->startElementNs(null, 'product', null);
            $this->product->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->availability) {
            foreach ($this->availability as $i => $x) {
                $writer->startElementNs(null, 'availability', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->price_group_id) {
            $writer->startElementNs(null, 'price_group_id', null);
            $writer->text($this->price_group_id);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class Task
{

    /**
     * unique task id in the company_id
     *
     * @var integer
     */
    private $id;

    /**
     * company_id the task belongs to
     *
     * @var integer
     */
    private $company_id;

    /**
     * (short) task heading
     *
     * @var string
     */
    private $heading;

    /**
     * (long) description of the task
     *
     * @var string
     */
    private $content;

    /**
     * optional start time of the task
     *
     * @var integer
     */
    private $start_time;

    /**
     * optional stop time of the task
     *
     * @var integer
     */
    private $stop_time;

    /**
     * optional time set to popup a reminder
     *
     * @var integer
     */
    private $remind_time;

    /**
     * optional related to a customer_id
     *
     * @var integer
     */
    private $customer_id;

    /**
     * optional related to an order
     *
     * @var integer
     */
    private $order_id;

    /**
     * set to true if task is completed
     *
     * @var boolean
     */
    private $completed;

    /**
     * set to the visbook user id who owns the task
     *
     * @var integer
     */
    private $user_id;

    /**
     * optional list of DocumentReference&#39;s attached to the task (images, pdf&#39;s etc)
     *
     * @var \App\Traits\DocumentReference[]
     */
    private $document;

    /**
     * task priority
     *
     * @var integer
     */
    private $priority;

    /**
     * Constructs a Task from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * unique task id in the company_id
     *
     * @return integer
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * unique task id in the company_id
     *
     * @param integer $id
     */
    public function setId($id)
    {
        $this->id = $id;
    }
    /**
     * company_id the task belongs to
     *
     * @return integer
     */
    public function getCompany_id()
    {
        return $this->company_id;
    }

    /**
     * company_id the task belongs to
     *
     * @param integer $company_id
     */
    public function setCompany_id($company_id)
    {
        $this->company_id = $company_id;
    }
    /**
     * (short) task heading
     *
     * @return string
     */
    public function getHeading()
    {
        return $this->heading;
    }

    /**
     * (short) task heading
     *
     * @param string $heading
     */
    public function setHeading($heading)
    {
        $this->heading = $heading;
    }
    /**
     * (long) description of the task
     *
     * @return string
     */
    public function getContent()
    {
        return $this->content;
    }

    /**
     * (long) description of the task
     *
     * @param string $content
     */
    public function setContent($content)
    {
        $this->content = $content;
    }
    /**
     * optional start time of the task
     *
     * @return integer
     */
    public function getStart_time()
    {
        return $this->start_time;
    }

    /**
     * optional start time of the task
     *
     * @param integer $start_time
     */
    public function setStart_time($start_time)
    {
        $this->start_time = $start_time;
    }
    /**
     * optional stop time of the task
     *
     * @return integer
     */
    public function getStop_time()
    {
        return $this->stop_time;
    }

    /**
     * optional stop time of the task
     *
     * @param integer $stop_time
     */
    public function setStop_time($stop_time)
    {
        $this->stop_time = $stop_time;
    }
    /**
     * optional time set to popup a reminder
     *
     * @return integer
     */
    public function getRemind_time()
    {
        return $this->remind_time;
    }

    /**
     * optional time set to popup a reminder
     *
     * @param integer $remind_time
     */
    public function setRemind_time($remind_time)
    {
        $this->remind_time = $remind_time;
    }
    /**
     * optional related to a customer_id
     *
     * @return integer
     */
    public function getCustomer_id()
    {
        return $this->customer_id;
    }

    /**
     * optional related to a customer_id
     *
     * @param integer $customer_id
     */
    public function setCustomer_id($customer_id)
    {
        $this->customer_id = $customer_id;
    }
    /**
     * optional related to an order
     *
     * @return integer
     */
    public function getOrder_id()
    {
        return $this->order_id;
    }

    /**
     * optional related to an order
     *
     * @param integer $order_id
     */
    public function setOrder_id($order_id)
    {
        $this->order_id = $order_id;
    }
    /**
     * set to true if task is completed
     *
     * @return boolean
     */
    public function getCompleted()
    {
        return $this->completed;
    }

    /**
     * set to true if task is completed
     *
     * @param boolean $completed
     */
    public function setCompleted($completed)
    {
        $this->completed = $completed;
    }
    /**
     * set to the visbook user id who owns the task
     *
     * @return integer
     */
    public function getUser_id()
    {
        return $this->user_id;
    }

    /**
     * set to the visbook user id who owns the task
     *
     * @param integer $user_id
     */
    public function setUser_id($user_id)
    {
        $this->user_id = $user_id;
    }
    /**
     * optional list of DocumentReference&#39;s attached to the task (images, pdf&#39;s etc)
     *
     * @return \App\Traits\DocumentReference[]
     */
    public function getDocument()
    {
        return $this->document;
    }

    /**
     * optional list of DocumentReference&#39;s attached to the task (images, pdf&#39;s etc)
     *
     * @param \App\Traits\DocumentReference[] $document
     */
    public function setDocument($document)
    {
        $this->document = $document;
    }
    /**
     * task priority
     *
     * @return integer
     */
    public function getPriority()
    {
        return $this->priority;
    }

    /**
     * task priority
     *
     * @param integer $priority
     */
    public function setPriority($priority)
    {
        $this->priority = $priority;
    }

    /**
     * Initializes this Task from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of Task from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'company_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->company_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'heading') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->heading = $child;
            $happened = true;
        }
        else if (($xml->localName == 'content') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->content = $child;
            $happened = true;
        }
        else if (($xml->localName == 'start_time') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->start_time = $child;
            $happened = true;
        }
        else if (($xml->localName == 'stop_time') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->stop_time = $child;
            $happened = true;
        }
        else if (($xml->localName == 'remind_time') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->remind_time = $child;
            $happened = true;
        }
        else if (($xml->localName == 'customer_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->customer_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'order_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->order_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'completed') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->completed = $child;
            $happened = true;
        }
        else if (($xml->localName == 'user_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->user_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'document') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\DocumentReference($xml);
            if (!isset($this->document)) {
                $this->document = array();
            }
            array_push($this->document, $child);
            $happened = true;
        }
        else if (($xml->localName == 'priority') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->priority = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of Task from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this Task to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->id) {
            $writer->startElementNs(null, 'id', null);
            $writer->text($this->id);
            $writer->endElement();
        }
        if ($this->company_id) {
            $writer->startElementNs(null, 'company_id', null);
            $writer->text($this->company_id);
            $writer->endElement();
        }
        if ($this->heading) {
            $writer->startElementNs(null, 'heading', null);
            $writer->text($this->heading);
            $writer->endElement();
        }
        if ($this->content) {
            $writer->startElementNs(null, 'content', null);
            $writer->text($this->content);
            $writer->endElement();
        }
        if ($this->start_time) {
            $writer->startElementNs(null, 'start_time', null);
            $writer->text($this->start_time);
            $writer->endElement();
        }
        if ($this->stop_time) {
            $writer->startElementNs(null, 'stop_time', null);
            $writer->text($this->stop_time);
            $writer->endElement();
        }
        if ($this->remind_time) {
            $writer->startElementNs(null, 'remind_time', null);
            $writer->text($this->remind_time);
            $writer->endElement();
        }
        if ($this->customer_id) {
            $writer->startElementNs(null, 'customer_id', null);
            $writer->text($this->customer_id);
            $writer->endElement();
        }
        if ($this->order_id) {
            $writer->startElementNs(null, 'order_id', null);
            $writer->text($this->order_id);
            $writer->endElement();
        }
        if ($this->completed) {
            $writer->startElementNs(null, 'completed', null);
            $writer->text($this->completed);
            $writer->endElement();
        }
        if ($this->user_id) {
            $writer->startElementNs(null, 'user_id', null);
            $writer->text($this->user_id);
            $writer->endElement();
        }
        if ($this->document) {
            foreach ($this->document as $i => $x) {
                $writer->startElementNs(null, 'document', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->priority) {
            $writer->startElementNs(null, 'priority', null);
            $writer->text($this->priority);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class TryChangeOrderResult
{

    /**
     * contains the order (with booking objects) as it would have been changed
     *
     * @var \App\Traits\Order
     */
    private $order;

    /**
     * empty, or contains a list of ErrorMessage&#39;s detected in changes on the order level
     *
     * @var \App\Traits\ErrorMessage[]
     */
    private $errors;

    /**
     * boolean set to true if no errors was detected
     *
     * @var boolean
     */
    private $success;

    /**
     * list of TryChangeBookingResult objects for each booking in the order, containing change results on booking level
     *
     * @var \App\Traits\TryChangeBookingResult[]
     */
    private $bookings;

    /**
     * Constructs a TryChangeOrderResult from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * contains the order (with booking objects) as it would have been changed
     *
     * @return \App\Traits\Order
     */
    public function getOrder()
    {
        return $this->order;
    }

    /**
     * contains the order (with booking objects) as it would have been changed
     *
     * @param \App\Traits\Order $order
     */
    public function setOrder($order)
    {
        $this->order = $order;
    }
    /**
     * empty, or contains a list of ErrorMessage&#39;s detected in changes on the order level
     *
     * @return \App\Traits\ErrorMessage[]
     */
    public function getErrors()
    {
        return $this->errors;
    }

    /**
     * empty, or contains a list of ErrorMessage&#39;s detected in changes on the order level
     *
     * @param \App\Traits\ErrorMessage[] $errors
     */
    public function setErrors($errors)
    {
        $this->errors = $errors;
    }
    /**
     * boolean set to true if no errors was detected
     *
     * @return boolean
     */
    public function getSuccess()
    {
        return $this->success;
    }

    /**
     * boolean set to true if no errors was detected
     *
     * @param boolean $success
     */
    public function setSuccess($success)
    {
        $this->success = $success;
    }
    /**
     * list of TryChangeBookingResult objects for each booking in the order, containing change results on booking level
     *
     * @return \App\Traits\TryChangeBookingResult[]
     */
    public function getBookings()
    {
        return $this->bookings;
    }

    /**
     * list of TryChangeBookingResult objects for each booking in the order, containing change results on booking level
     *
     * @param \App\Traits\TryChangeBookingResult[] $bookings
     */
    public function setBookings($bookings)
    {
        $this->bookings = $bookings;
    }

    /**
     * Initializes this TryChangeOrderResult from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of TryChangeOrderResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'order') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\Order($xml);
            $this->order = $child;
            $happened = true;
        }
        else if (($xml->localName == 'errors') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\ErrorMessage($xml);
            if (!isset($this->errors)) {
                $this->errors = array();
            }
            array_push($this->errors, $child);
            $happened = true;
        }
        else if (($xml->localName == 'success') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->success = $child;
            $happened = true;
        }
        else if (($xml->localName == 'bookings') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\TryChangeBookingResult($xml);
            if (!isset($this->bookings)) {
                $this->bookings = array();
            }
            array_push($this->bookings, $child);
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of TryChangeOrderResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this TryChangeOrderResult to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->order) {
            $writer->startElementNs(null, 'order', null);
            $this->order->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->errors) {
            foreach ($this->errors as $i => $x) {
                $writer->startElementNs(null, 'errors', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->success) {
            $writer->startElementNs(null, 'success', null);
            $writer->text($this->success);
            $writer->endElement();
        }
        if ($this->bookings) {
            foreach ($this->bookings as $i => $x) {
                $writer->startElementNs(null, 'bookings', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class VATInfo
{

    /**
     * The VAT percentage
     *
     * @var double
     */
    private $percentage;

    /**
     * The amount to be taxed for this percentage
     *
     * @var double
     */
    private $amount;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $account_id;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $from;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $to;

    /**
     * Constructs a VATInfo from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * The VAT percentage
     *
     * @return double
     */
    public function getPercentage()
    {
        return $this->percentage;
    }

    /**
     * The VAT percentage
     *
     * @param double $percentage
     */
    public function setPercentage($percentage)
    {
        $this->percentage = $percentage;
    }
    /**
     * The amount to be taxed for this percentage
     *
     * @return double
     */
    public function getAmount()
    {
        return $this->amount;
    }

    /**
     * The amount to be taxed for this percentage
     *
     * @param double $amount
     */
    public function setAmount($amount)
    {
        $this->amount = $amount;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getAccount_id()
    {
        return $this->account_id;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $account_id
     */
    public function setAccount_id($account_id)
    {
        $this->account_id = $account_id;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getFrom()
    {
        return $this->from;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $from
     */
    public function setFrom($from)
    {
        $this->from = $from;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getTo()
    {
        return $this->to;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $to
     */
    public function setTo($to)
    {
        $this->to = $to;
    }

    /**
     * Initializes this VATInfo from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of VATInfo from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'percentage') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->percentage = $child;
            $happened = true;
        }
        else if (($xml->localName == 'amount') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->amount = $child;
            $happened = true;
        }
        else if (($xml->localName == 'account_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->account_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'from') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->from = $child;
            $happened = true;
        }
        else if (($xml->localName == 'to') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->to = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of VATInfo from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this VATInfo to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->percentage) {
            $writer->startElementNs(null, 'percentage', null);
            $writer->text($this->percentage);
            $writer->endElement();
        }
        if ($this->amount) {
            $writer->startElementNs(null, 'amount', null);
            $writer->text($this->amount);
            $writer->endElement();
        }
        if ($this->account_id) {
            $writer->startElementNs(null, 'account_id', null);
            $writer->text($this->account_id);
            $writer->endElement();
        }
        if ($this->from) {
            $writer->startElementNs(null, 'from', null);
            $writer->text($this->from);
            $writer->endElement();
        }
        if ($this->to) {
            $writer->startElementNs(null, 'to', null);
            $writer->text($this->to);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class VBUser
{

    /**
     * home company id
     *
     * @var integer
     */
    private $company_id;

    /**
     * unique user id
     *
     * @var integer
     */
    private $user_id;

    /**
     * List of roles this user has
     *
     * @var \App\Traits\UserRole[]
     */
    private $roles;

    /**
     * user name (login name)
     *
     * @var string
     */
    private $user_name;

    /**
     * Constructs a VBUser from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * home company id
     *
     * @return integer
     */
    public function getCompany_id()
    {
        return $this->company_id;
    }

    /**
     * home company id
     *
     * @param integer $company_id
     */
    public function setCompany_id($company_id)
    {
        $this->company_id = $company_id;
    }
    /**
     * unique user id
     *
     * @return integer
     */
    public function getUser_id()
    {
        return $this->user_id;
    }

    /**
     * unique user id
     *
     * @param integer $user_id
     */
    public function setUser_id($user_id)
    {
        $this->user_id = $user_id;
    }
    /**
     * List of roles this user has
     *
     * @return \App\Traits\UserRole[]
     */
    public function getRoles()
    {
        return $this->roles;
    }

    /**
     * List of roles this user has
     *
     * @param \App\Traits\UserRole[] $roles
     */
    public function setRoles($roles)
    {
        $this->roles = $roles;
    }
    /**
     * user name (login name)
     *
     * @return string
     */
    public function getUser_name()
    {
        return $this->user_name;
    }

    /**
     * user name (login name)
     *
     * @param string $user_name
     */
    public function setUser_name($user_name)
    {
        $this->user_name = $user_name;
    }

    /**
     * Initializes this VBUser from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of VBUser from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'company_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->company_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'user_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->user_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'roles') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\UserRole($xml);
            if (!isset($this->roles)) {
                $this->roles = array();
            }
            array_push($this->roles, $child);
            $happened = true;
        }
        else if (($xml->localName == 'user_name') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->user_name = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of VBUser from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this VBUser to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->company_id) {
            $writer->startElementNs(null, 'company_id', null);
            $writer->text($this->company_id);
            $writer->endElement();
        }
        if ($this->user_id) {
            $writer->startElementNs(null, 'user_id', null);
            $writer->text($this->user_id);
            $writer->endElement();
        }
        if ($this->roles) {
            foreach ($this->roles as $i => $x) {
                $writer->startElementNs(null, 'roles', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->user_name) {
            $writer->startElementNs(null, 'user_name', null);
            $writer->text($this->user_name);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class UserRole
{

    /**
     * user id
     *
     * @var integer
     */
    private $user_id;

    /**
     * company_id
     *
     * @var integer
     */
    private $company_id;

    /**
     * role_id (documentation missing)
     *
     * @var integer
     */
    private $role_id;

    /**
     * Constructs a UserRole from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * user id
     *
     * @return integer
     */
    public function getUser_id()
    {
        return $this->user_id;
    }

    /**
     * user id
     *
     * @param integer $user_id
     */
    public function setUser_id($user_id)
    {
        $this->user_id = $user_id;
    }
    /**
     * company_id
     *
     * @return integer
     */
    public function getCompany_id()
    {
        return $this->company_id;
    }

    /**
     * company_id
     *
     * @param integer $company_id
     */
    public function setCompany_id($company_id)
    {
        $this->company_id = $company_id;
    }
    /**
     * role_id (documentation missing)
     *
     * @return integer
     */
    public function getRole_id()
    {
        return $this->role_id;
    }

    /**
     * role_id (documentation missing)
     *
     * @param integer $role_id
     */
    public function setRole_id($role_id)
    {
        $this->role_id = $role_id;
    }

    /**
     * Initializes this UserRole from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of UserRole from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'user_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->user_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'company_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->company_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'role_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->role_id = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of UserRole from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this UserRole to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->user_id) {
            $writer->startElementNs(null, 'user_id', null);
            $writer->text($this->user_id);
            $writer->endElement();
        }
        if ($this->company_id) {
            $writer->startElementNs(null, 'company_id', null);
            $writer->text($this->company_id);
            $writer->endElement();
        }
        if ($this->role_id) {
            $writer->startElementNs(null, 'role_id', null);
            $writer->text($this->role_id);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class TryChangeBookingResult
{

    /**
     * copy of the booking sendt in as argument to try_change_order
     *
     * @var \App\Traits\Booking
     */
    private $booking;

    /**
     * list of ErrorMessage&#39;s
     *
     * @var \App\Traits\ErrorMessage[]
     */
    private $errors;

    /**
     * (for debug purposes/logging) verbose string message of what changes was detected
     *
     * @var string
     */
    private $changeMessage;

    /**
     * Constructs a TryChangeBookingResult from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * copy of the booking sendt in as argument to try_change_order
     *
     * @return \App\Traits\Booking
     */
    public function getBooking()
    {
        return $this->booking;
    }

    /**
     * copy of the booking sendt in as argument to try_change_order
     *
     * @param \App\Traits\Booking $booking
     */
    public function setBooking($booking)
    {
        $this->booking = $booking;
    }
    /**
     * list of ErrorMessage&#39;s
     *
     * @return \App\Traits\ErrorMessage[]
     */
    public function getErrors()
    {
        return $this->errors;
    }

    /**
     * list of ErrorMessage&#39;s
     *
     * @param \App\Traits\ErrorMessage[] $errors
     */
    public function setErrors($errors)
    {
        $this->errors = $errors;
    }
    /**
     * (for debug purposes/logging) verbose string message of what changes was detected
     *
     * @return string
     */
    public function getChangeMessage()
    {
        return $this->changeMessage;
    }

    /**
     * (for debug purposes/logging) verbose string message of what changes was detected
     *
     * @param string $changeMessage
     */
    public function setChangeMessage($changeMessage)
    {
        $this->changeMessage = $changeMessage;
    }

    /**
     * Initializes this TryChangeBookingResult from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of TryChangeBookingResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'booking') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\Booking($xml);
            $this->booking = $child;
            $happened = true;
        }
        else if (($xml->localName == 'errors') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\ErrorMessage($xml);
            if (!isset($this->errors)) {
                $this->errors = array();
            }
            array_push($this->errors, $child);
            $happened = true;
        }
        else if (($xml->localName == 'changeMessage') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->changeMessage = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of TryChangeBookingResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this TryChangeBookingResult to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->booking) {
            $writer->startElementNs(null, 'booking', null);
            $this->booking->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->errors) {
            foreach ($this->errors as $i => $x) {
                $writer->startElementNs(null, 'errors', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->changeMessage) {
            $writer->startElementNs(null, 'changeMessage', null);
            $writer->text($this->changeMessage);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class ProductAvailabilityRange
{

    /**
     * Range start date (including)
     *
     * @var integer
     */
    private $from_date;

    /**
     * Range end date (including)
     *
     * @var integer
     */
    private $to_date;

    /**
     * Availability count (number of available products)
     *
     * @var integer
     */
    private $availability;

    /**
     * Constructs a ProductAvailabilityRange from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * Range start date (including)
     *
     * @return integer
     */
    public function getFrom_date()
    {
        return $this->from_date;
    }

    /**
     * Range start date (including)
     *
     * @param integer $from_date
     */
    public function setFrom_date($from_date)
    {
        $this->from_date = $from_date;
    }
    /**
     * Range end date (including)
     *
     * @return integer
     */
    public function getTo_date()
    {
        return $this->to_date;
    }

    /**
     * Range end date (including)
     *
     * @param integer $to_date
     */
    public function setTo_date($to_date)
    {
        $this->to_date = $to_date;
    }
    /**
     * Availability count (number of available products)
     *
     * @return integer
     */
    public function getAvailability()
    {
        return $this->availability;
    }

    /**
     * Availability count (number of available products)
     *
     * @param integer $availability
     */
    public function setAvailability($availability)
    {
        $this->availability = $availability;
    }

    /**
     * Initializes this ProductAvailabilityRange from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of ProductAvailabilityRange from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'from_date') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->from_date = $child;
            $happened = true;
        }
        else if (($xml->localName == 'to_date') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->to_date = $child;
            $happened = true;
        }
        else if (($xml->localName == 'availability') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->availability = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of ProductAvailabilityRange from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this ProductAvailabilityRange to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->from_date) {
            $writer->startElementNs(null, 'from_date', null);
            $writer->text($this->from_date);
            $writer->endElement();
        }
        if ($this->to_date) {
            $writer->startElementNs(null, 'to_date', null);
            $writer->text($this->to_date);
            $writer->endElement();
        }
        if ($this->availability) {
            $writer->startElementNs(null, 'availability', null);
            $writer->text($this->availability);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class PriceDay
{

    /**
     * the day number from when the price is valid from
     *
     * @var integer
     */
    private $day;

    /**
     * price value for the specified day
     *
     * @var double
     */
    private $price;

    /**
     * Constructs a PriceDay from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * the day number from when the price is valid from
     *
     * @return integer
     */
    public function getDay()
    {
        return $this->day;
    }

    /**
     * the day number from when the price is valid from
     *
     * @param integer $day
     */
    public function setDay($day)
    {
        $this->day = $day;
    }
    /**
     * price value for the specified day
     *
     * @return double
     */
    public function getPrice()
    {
        return $this->price;
    }

    /**
     * price value for the specified day
     *
     * @param double $price
     */
    public function setPrice($price)
    {
        $this->price = $price;
    }

    /**
     * Initializes this PriceDay from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of PriceDay from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'day') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->day = $child;
            $happened = true;
        }
        else if (($xml->localName == 'price') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->price = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of PriceDay from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this PriceDay to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->day) {
            $writer->startElementNs(null, 'day', null);
            $writer->text($this->day);
            $writer->endElement();
        }
        if ($this->price) {
            $writer->startElementNs(null, 'price', null);
            $writer->text($this->price);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class Person
{

    /**
     * unique identificator
     *
     * @var integer
     */
    private $id;

    /**
     * linked to this customer id
     *
     * @var integer
     */
    private $customer_id;

    /**
     * given name of the person
     *
     * @var string
     */
    private $given_name;

    /**
     * the last name of the person
     *
     * @var string
     */
    private $surname;

    /**
     * street name or address
     *
     * @var string
     */
    private $address;

    /**
     * zip code
     *
     * @var string
     */
    private $zip_code;

    /**
     * city
     *
     * @var string
     */
    private $city;

    /**
     * iso 3166 country id (see get_country_codes command)
     *
     * @var integer
     */
    private $country_code;

    /**
     * phone number
     *
     * @var string
     */
    private $phone;

    /**
     * email address
     *
     * @var string
     */
    private $email;

    /**
     * last changed timestamp of this record
     *
     * @var integer
     */
    private $changed_date;

    /**
     * Constructs a Person from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * unique identificator
     *
     * @return integer
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * unique identificator
     *
     * @param integer $id
     */
    public function setId($id)
    {
        $this->id = $id;
    }
    /**
     * linked to this customer id
     *
     * @return integer
     */
    public function getCustomer_id()
    {
        return $this->customer_id;
    }

    /**
     * linked to this customer id
     *
     * @param integer $customer_id
     */
    public function setCustomer_id($customer_id)
    {
        $this->customer_id = $customer_id;
    }
    /**
     * given name of the person
     *
     * @return string
     */
    public function getGiven_name()
    {
        return $this->given_name;
    }

    /**
     * given name of the person
     *
     * @param string $given_name
     */
    public function setGiven_name($given_name)
    {
        $this->given_name = $given_name;
    }
    /**
     * the last name of the person
     *
     * @return string
     */
    public function getSurname()
    {
        return $this->surname;
    }

    /**
     * the last name of the person
     *
     * @param string $surname
     */
    public function setSurname($surname)
    {
        $this->surname = $surname;
    }
    /**
     * street name or address
     *
     * @return string
     */
    public function getAddress()
    {
        return $this->address;
    }

    /**
     * street name or address
     *
     * @param string $address
     */
    public function setAddress($address)
    {
        $this->address = $address;
    }
    /**
     * zip code
     *
     * @return string
     */
    public function getZip_code()
    {
        return $this->zip_code;
    }

    /**
     * zip code
     *
     * @param string $zip_code
     */
    public function setZip_code($zip_code)
    {
        $this->zip_code = $zip_code;
    }
    /**
     * city
     *
     * @return string
     */
    public function getCity()
    {
        return $this->city;
    }

    /**
     * city
     *
     * @param string $city
     */
    public function setCity($city)
    {
        $this->city = $city;
    }
    /**
     * iso 3166 country id (see get_country_codes command)
     *
     * @return integer
     */
    public function getCountry_code()
    {
        return $this->country_code;
    }

    /**
     * iso 3166 country id (see get_country_codes command)
     *
     * @param integer $country_code
     */
    public function setCountry_code($country_code)
    {
        $this->country_code = $country_code;
    }
    /**
     * phone number
     *
     * @return string
     */
    public function getPhone()
    {
        return $this->phone;
    }

    /**
     * phone number
     *
     * @param string $phone
     */
    public function setPhone($phone)
    {
        $this->phone = $phone;
    }
    /**
     * email address
     *
     * @return string
     */
    public function getEmail()
    {
        return $this->email;
    }

    /**
     * email address
     *
     * @param string $email
     */
    public function setEmail($email)
    {
        $this->email = $email;
    }
    /**
     * last changed timestamp of this record
     *
     * @return integer
     */
    public function getChanged_date()
    {
        return $this->changed_date;
    }

    /**
     * last changed timestamp of this record
     *
     * @param integer $changed_date
     */
    public function setChanged_date($changed_date)
    {
        $this->changed_date = $changed_date;
    }

    /**
     * Initializes this Person from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of Person from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'customer_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->customer_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'given_name') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->given_name = $child;
            $happened = true;
        }
        else if (($xml->localName == 'surname') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->surname = $child;
            $happened = true;
        }
        else if (($xml->localName == 'address') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->address = $child;
            $happened = true;
        }
        else if (($xml->localName == 'zip_code') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->zip_code = $child;
            $happened = true;
        }
        else if (($xml->localName == 'city') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->city = $child;
            $happened = true;
        }
        else if (($xml->localName == 'country_code') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->country_code = $child;
            $happened = true;
        }
        else if (($xml->localName == 'phone') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->phone = $child;
            $happened = true;
        }
        else if (($xml->localName == 'email') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->email = $child;
            $happened = true;
        }
        else if (($xml->localName == 'changed_date') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->changed_date = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of Person from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this Person to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->id) {
            $writer->startElementNs(null, 'id', null);
            $writer->text($this->id);
            $writer->endElement();
        }
        if ($this->customer_id) {
            $writer->startElementNs(null, 'customer_id', null);
            $writer->text($this->customer_id);
            $writer->endElement();
        }
        if ($this->given_name) {
            $writer->startElementNs(null, 'given_name', null);
            $writer->text($this->given_name);
            $writer->endElement();
        }
        if ($this->surname) {
            $writer->startElementNs(null, 'surname', null);
            $writer->text($this->surname);
            $writer->endElement();
        }
        if ($this->address) {
            $writer->startElementNs(null, 'address', null);
            $writer->text($this->address);
            $writer->endElement();
        }
        if ($this->zip_code) {
            $writer->startElementNs(null, 'zip_code', null);
            $writer->text($this->zip_code);
            $writer->endElement();
        }
        if ($this->city) {
            $writer->startElementNs(null, 'city', null);
            $writer->text($this->city);
            $writer->endElement();
        }
        if ($this->country_code) {
            $writer->startElementNs(null, 'country_code', null);
            $writer->text($this->country_code);
            $writer->endElement();
        }
        if ($this->phone) {
            $writer->startElementNs(null, 'phone', null);
            $writer->text($this->phone);
            $writer->endElement();
        }
        if ($this->email) {
            $writer->startElementNs(null, 'email', null);
            $writer->text($this->email);
            $writer->endElement();
        }
        if ($this->changed_date) {
            $writer->startElementNs(null, 'changed_date', null);
            $writer->text($this->changed_date);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class Payment
{

    /**
     * paymentMethod associated with payment
     *
     * @var \App\Traits\PaymentMethod
     */
    private $method;

    /**
     * payment reference number/string
     *
     * @var string
     */
    private $ref;

    /**
     * creditCardId
     *
     * @var string
     */
    private $ccardid;

    /**
     * payment amount
     *
     * @var double
     */
    private $amount;

    /**
     * timestamp of the payment
     *
     * @var integer
     */
    private $registration_date;

    /**
     * optional related booking id
     *
     * @var integer
     */
    private $master_booking_id;

    /**
     * Constructs a Payment from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * paymentMethod associated with payment
     *
     * @return \App\Traits\PaymentMethod
     */
    public function getMethod()
    {
        return $this->method;
    }

    /**
     * paymentMethod associated with payment
     *
     * @param \App\Traits\PaymentMethod $method
     */
    public function setMethod($method)
    {
        $this->method = $method;
    }
    /**
     * payment reference number/string
     *
     * @return string
     */
    public function getRef()
    {
        return $this->ref;
    }

    /**
     * payment reference number/string
     *
     * @param string $ref
     */
    public function setRef($ref)
    {
        $this->ref = $ref;
    }
    /**
     * creditCardId
     *
     * @return string
     */
    public function getCcardid()
    {
        return $this->ccardid;
    }

    /**
     * creditCardId
     *
     * @param string $ccardid
     */
    public function setCcardid($ccardid)
    {
        $this->ccardid = $ccardid;
    }
    /**
     * payment amount
     *
     * @return double
     */
    public function getAmount()
    {
        return $this->amount;
    }

    /**
     * payment amount
     *
     * @param double $amount
     */
    public function setAmount($amount)
    {
        $this->amount = $amount;
    }
    /**
     * timestamp of the payment
     *
     * @return integer
     */
    public function getRegistration_date()
    {
        return $this->registration_date;
    }

    /**
     * timestamp of the payment
     *
     * @param integer $registration_date
     */
    public function setRegistration_date($registration_date)
    {
        $this->registration_date = $registration_date;
    }
    /**
     * optional related booking id
     *
     * @return integer
     */
    public function getMaster_booking_id()
    {
        return $this->master_booking_id;
    }

    /**
     * optional related booking id
     *
     * @param integer $master_booking_id
     */
    public function setMaster_booking_id($master_booking_id)
    {
        $this->master_booking_id = $master_booking_id;
    }

    /**
     * Initializes this Payment from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of Payment from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'method') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\PaymentMethod($xml);
            $this->method = $child;
            $happened = true;
        }
        else if (($xml->localName == 'ref') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->ref = $child;
            $happened = true;
        }
        else if (($xml->localName == 'ccardid') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->ccardid = $child;
            $happened = true;
        }
        else if (($xml->localName == 'amount') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->amount = $child;
            $happened = true;
        }
        else if (($xml->localName == 'registration_date') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->registration_date = $child;
            $happened = true;
        }
        else if (($xml->localName == 'master_booking_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->master_booking_id = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of Payment from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this Payment to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->method) {
            $writer->startElementNs(null, 'method', null);
            $this->method->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->ref) {
            $writer->startElementNs(null, 'ref', null);
            $writer->text($this->ref);
            $writer->endElement();
        }
        if ($this->ccardid) {
            $writer->startElementNs(null, 'ccardid', null);
            $writer->text($this->ccardid);
            $writer->endElement();
        }
        if ($this->amount) {
            $writer->startElementNs(null, 'amount', null);
            $writer->text($this->amount);
            $writer->endElement();
        }
        if ($this->registration_date) {
            $writer->startElementNs(null, 'registration_date', null);
            $writer->text($this->registration_date);
            $writer->endElement();
        }
        if ($this->master_booking_id) {
            $writer->startElementNs(null, 'master_booking_id', null);
            $writer->text($this->master_booking_id);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class ErrorMessage
{

    /**
     * integer code:
     * &lt;pre&gt;
     * 1 = UNDEFINED_ERROR – general undefined error
     * 2 = BLOCKING_BOOKING – not enough availability/ a booking is blocking the operation
     * 3 = INSIDE_CLOSED_PERIOD – the order/booking is inside a closed accounting period, preventing modifications that will generate accounting errors
     * 4 = NOT_FOUND – non existing object
     * 5 = STATUS_PREVENT_CHANGE – status on order/booking prevents the requested changes
     * 6 = CONCURRENT_CHANGE – detected that the last changed timestamp on the requested object is is not matching the provided timestamp
     * 7 = ILLEGAL_PRICE – arguments provided causes price calculation errors (division by zero, or price is lower than fixed price settings)
     *     &lt;/pre&gt;
     *
     * @var integer
     */
    private $code;

    /**
     * error message in english
     *
     * @var string
     */
    private $message;

    /**
     * Constructs a ErrorMessage from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * integer code:
       * &lt;pre&gt;
       * 1 = UNDEFINED_ERROR – general undefined error
       * 2 = BLOCKING_BOOKING – not enough availability/ a booking is blocking the operation
       * 3 = INSIDE_CLOSED_PERIOD – the order/booking is inside a closed accounting period, preventing modifications that will generate accounting errors
       * 4 = NOT_FOUND – non existing object
       * 5 = STATUS_PREVENT_CHANGE – status on order/booking prevents the requested changes
       * 6 = CONCURRENT_CHANGE – detected that the last changed timestamp on the requested object is is not matching the provided timestamp
       * 7 = ILLEGAL_PRICE – arguments provided causes price calculation errors (division by zero, or price is lower than fixed price settings)
       *     &lt;/pre&gt;
     *
     * @return integer
     */
    public function getCode()
    {
        return $this->code;
    }

    /**
     * integer code:
       * &lt;pre&gt;
       * 1 = UNDEFINED_ERROR – general undefined error
       * 2 = BLOCKING_BOOKING – not enough availability/ a booking is blocking the operation
       * 3 = INSIDE_CLOSED_PERIOD – the order/booking is inside a closed accounting period, preventing modifications that will generate accounting errors
       * 4 = NOT_FOUND – non existing object
       * 5 = STATUS_PREVENT_CHANGE – status on order/booking prevents the requested changes
       * 6 = CONCURRENT_CHANGE – detected that the last changed timestamp on the requested object is is not matching the provided timestamp
       * 7 = ILLEGAL_PRICE – arguments provided causes price calculation errors (division by zero, or price is lower than fixed price settings)
       *     &lt;/pre&gt;
     *
     * @param integer $code
     */
    public function setCode($code)
    {
        $this->code = $code;
    }
    /**
     * error message in english
     *
     * @return string
     */
    public function getMessage()
    {
        return $this->message;
    }

    /**
     * error message in english
     *
     * @param string $message
     */
    public function setMessage($message)
    {
        $this->message = $message;
    }

    /**
     * Initializes this ErrorMessage from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of ErrorMessage from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'code') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->code = $child;
            $happened = true;
        }
        else if (($xml->localName == 'message') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->message = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of ErrorMessage from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this ErrorMessage to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->code) {
            $writer->startElementNs(null, 'code', null);
            $writer->text($this->code);
            $writer->endElement();
        }
        if ($this->message) {
            $writer->startElementNs(null, 'message', null);
            $writer->text($this->message);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class CustomerCategory
{

    /**
     * hotel/company unique identificator of the customer category (Note: not equal between multiple companies)
     *
     * @var integer
     */
    private $id;

    /**
     * textual name of the category
     *
     * @var string
     */
    private $name;

    /**
     * Constructs a CustomerCategory from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * hotel/company unique identificator of the customer category (Note: not equal between multiple companies)
     *
     * @return integer
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * hotel/company unique identificator of the customer category (Note: not equal between multiple companies)
     *
     * @param integer $id
     */
    public function setId($id)
    {
        $this->id = $id;
    }
    /**
     * textual name of the category
     *
     * @return string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * textual name of the category
     *
     * @param string $name
     */
    public function setName($name)
    {
        $this->name = $name;
    }

    /**
     * Initializes this CustomerCategory from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of CustomerCategory from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'name') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->name = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of CustomerCategory from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this CustomerCategory to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->id) {
            $writer->startElementNs(null, 'id', null);
            $writer->text($this->id);
            $writer->endElement();
        }
        if ($this->name) {
            $writer->startElementNs(null, 'name', null);
            $writer->text($this->name);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class Country
{

    /**
     * iso_3166 country code
     *
     * @var integer
     */
    private $country_code;

    /**
     * textual name of the country
     *
     * @var string
     */
    private $name;

    /**
     * iso_3166 two letter code
     *
     * @var string
     */
    private $A2;

    /**
     * iso_3166 three letter code
     *
     * @var string
     */
    private $A3;

    /**
     * Constructs a Country from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * iso_3166 country code
     *
     * @return integer
     */
    public function getCountry_code()
    {
        return $this->country_code;
    }

    /**
     * iso_3166 country code
     *
     * @param integer $country_code
     */
    public function setCountry_code($country_code)
    {
        $this->country_code = $country_code;
    }
    /**
     * textual name of the country
     *
     * @return string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * textual name of the country
     *
     * @param string $name
     */
    public function setName($name)
    {
        $this->name = $name;
    }
    /**
     * iso_3166 two letter code
     *
     * @return string
     */
    public function getA2()
    {
        return $this->A2;
    }

    /**
     * iso_3166 two letter code
     *
     * @param string $A2
     */
    public function setA2($A2)
    {
        $this->A2 = $A2;
    }
    /**
     * iso_3166 three letter code
     *
     * @return string
     */
    public function getA3()
    {
        return $this->A3;
    }

    /**
     * iso_3166 three letter code
     *
     * @param string $A3
     */
    public function setA3($A3)
    {
        $this->A3 = $A3;
    }

    /**
     * Initializes this Country from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of Country from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'country_code') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->country_code = $child;
            $happened = true;
        }
        else if (($xml->localName == 'name') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->name = $child;
            $happened = true;
        }
        else if (($xml->localName == 'A2') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->A2 = $child;
            $happened = true;
        }
        else if (($xml->localName == 'A3') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->A3 = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of Country from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this Country to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->country_code) {
            $writer->startElementNs(null, 'country_code', null);
            $writer->text($this->country_code);
            $writer->endElement();
        }
        if ($this->name) {
            $writer->startElementNs(null, 'name', null);
            $writer->text($this->name);
            $writer->endElement();
        }
        if ($this->A2) {
            $writer->startElementNs(null, 'A2', null);
            $writer->text($this->A2);
            $writer->endElement();
        }
        if ($this->A3) {
            $writer->startElementNs(null, 'A3', null);
            $writer->text($this->A3);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class CleaningStation
{

    /**
     * company unique id for the cleaning station
     *
     * @var integer
     */
    private $id;

    /**
     * Cleaning station name
     *
     * @var string
     */
    private $name;

    /**
     * Constructs a CleaningStation from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * company unique id for the cleaning station
     *
     * @return integer
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * company unique id for the cleaning station
     *
     * @param integer $id
     */
    public function setId($id)
    {
        $this->id = $id;
    }
    /**
     * Cleaning station name
     *
     * @return string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * Cleaning station name
     *
     * @param string $name
     */
    public function setName($name)
    {
        $this->name = $name;
    }

    /**
     * Initializes this CleaningStation from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of CleaningStation from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'name') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->name = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of CleaningStation from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this CleaningStation to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->id) {
            $writer->startElementNs(null, 'id', null);
            $writer->text($this->id);
            $writer->endElement();
        }
        if ($this->name) {
            $writer->startElementNs(null, 'name', null);
            $writer->text($this->name);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class User
{

    /**
     * Username for the user
     *
     * @var string
     */
    private $username;

    /**
     * Password for the user
     *
     * @var string
     */
    private $password;

    /**
     * Constructs a User from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * Username for the user
     *
     * @return string
     */
    public function getUsername()
    {
        return $this->username;
    }

    /**
     * Username for the user
     *
     * @param string $username
     */
    public function setUsername($username)
    {
        $this->username = $username;
    }
    /**
     * Password for the user
     *
     * @return string
     */
    public function getPassword()
    {
        return $this->password;
    }

    /**
     * Password for the user
     *
     * @param string $password
     */
    public function setPassword($password)
    {
        $this->password = $password;
    }

    /**
     * Initializes this User from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of User from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'username') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->username = $child;
            $happened = true;
        }
        else if (($xml->localName == 'password') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->password = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of User from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this User to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->username) {
            $writer->startElementNs(null, 'username', null);
            $writer->text($this->username);
            $writer->endElement();
        }
        if ($this->password) {
            $writer->startElementNs(null, 'password', null);
            $writer->text($this->password);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class ExternalBookingReferenceType
{

    /**
     * used when searching a reference of any type
     */
    const ANY = "ANY";

    /**
     * booking.com reference_id
     */
    const BOOKINGDOTCOM = "BOOKINGDOTCOM";

    /**
     * SynXis
     */
    const SYNXIS = "SYNXIS";

    /**
     * hotels.com
     */
    const HOTELSCOM = "HOTELSCOM";

    /**
     *
     */
    const EXPEDIA = "EXPEDIA";

    /**
     *
     */
    const HRS = "HRS";

    /**
     * Use this for registering any other type
     */
    const OTHERS = "OTHERS";

    /**
     *
     */
    const CITYBREAK = "CITYBREAK";

    /**
     *
     */
    const AROBS = "AROBS";

    /**
     *
     */
    const AMADEUS = "AMADEUS";

    /**
     *
     */
    const THOMAS = "THOMAS";

    /**
     *
     */
    const HOTELZON = "HOTELZON";

    /**
     *
     */
    const RATEWIZZ = "RATEWIZZ";

    /**
     *
     */
    const BOOKVISIT = "BOOKVISIT";

    /**
     *
     */
    const CITYBREAK_DESTINATION = "CITYBREAK_DESTINATION";

    /**
     *
     */
    const XPAND = "XPAND";
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class CurrencyType
{

    /**
     *
     */
    const USD = "USD";

    /**
     *
     */
    const EUR = "EUR";

    /**
     *
     */
    const NOK = "NOK";

    /**
     *
     */
    const SEK = "SEK";

    /**
     *
     */
    const DKK = "DKK";

    /**
     *
     */
    const GBP = "GBP";

    /**
     *
     */
    const ISK = "ISK";
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class Language
{

    /**
     *
     */
    const NORWEGIAN = "norwegian";

    /**
     *
     */
    const ENGLISH = "english";

    /**
     *
     */
    const GERMAN = "german";

    /**
     *
     */
    const SWEDISH = "swedish";
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class ProductType
{

    /**
     * Typically a room/bed in a hotel, cabin, caravan
    * &lt;li&gt;this type has always an arrival date and departure date at least one day long, but ignores the time field.
    * &lt;li&gt; This type may have several different prices (half pension, full pension, breakfast price)
     */
    const ACCOMMODATION = "accommodation";

    /**
     * typically timebased rental objects like a boat, fishing-rods, etc.
    * &lt;li&gt;this type has always both from and to date and time specification
     */
    const ACTIVITY = "activity";

    /**
     * typically bedlinen, towels etc
    * &lt;li&gt;always has fromdate and todate, often follows the arrival and departure date for a accommodation product
     */
    const SERVICE = "service";

    /**
     * typically goods and merchandise that is purchased like a dinner, beer, newspaper etc...
     */
    const MERCHANDISE = "merchandise";

    /**
     * special type used in reply of find_orders for free-form text (comments) appended to the order
     */
    const TEXT = "text";

    /**
     * reserved for future use
     */
    const SYSTEM = "system";
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class PriceType
{

    /**
     *
     */
    const UNKNOWN = "UNKNOWN";

    /**
     *
     */
    const PRICE_PER_DAY = "PRICE_PER_DAY";

    /**
     *
     */
    const PRICE_PER_PERSON = "PRICE_PER_PERSON";
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class Operator
{

    /**
     *
     */
    const UNDEFINED = "UNDEFINED";

    /**
     * =
     */
    const EQUAL = "EQUAL";

    /**
     * &amp;lt;
     */
    const LESS_THAN = "LESS_THAN";

    /**
     * &amp;gt;
     */
    const MORE_THAN = "MORE_THAN";

    /**
     * &amp;lt;&amp;gt;, or !=
     */
    const NOT_EQUAL = "NOT_EQUAL";

    /**
     * &amp;lt;=
     */
    const LESS_OR_EQUAL = "LESS_OR_EQUAL";

    /**
     * &amp;gt;=
     */
    const MORE_OR_EQUAL = "MORE_OR_EQUAL";

    /**
     * (Attribute text value contains case sensitive string)
     */
    const CONTAINS = "CONTAINS";

    /**
     * (Attribute text value equals, but case insensitive)
     */
    const EQUAL_NONCASE = "EQUAL_NONCASE";

    /**
     * (Attribute text value contains, case insensitive)
     */
    const CONTAINS_NONCASE = "CONTAINS_NONCASE";
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class OrderProduct extends \App\Traits\Product
{

    /**
     * price object, to specify which price is to be used, see price object for description, if price_value is provided, this will override calculated price
     *
     * @var \App\Traits\Price
     */
    private $price;

    /**
     * the arrival date/time
     *
     * @var integer
     */
    private $from_date;

    /**
     * the departure date/time
     *
     * @var integer
     */
    private $to_date;

    /**
     * number of product units, f. ex. 2 rooms, 3 boats, 1 newspaper
     *
     * @var integer
     */
    private $units;

    /**
     * Total number of persons that is to use the product, f.ex a double room has typically 2 persons.
     *
     * @var integer
     */
    private $persons;

    /**
     * (optional) number of persons in rebate1 category
     *
     * @var integer
     */
    private $persons_rebate1;

    /**
     * (optional) number of persons in rebate2 category
     *
     * @var integer
     */
    private $persons_rebate2;

    /**
     * unique id (per company) that is non zero if the product is reserved, see reserve_products command
     *
     * @var integer
     */
    private $reservation_id;

    /**
     * (optional) String representing the person name who should check in on the object
     *
     * @var string
     */
    private $person_name;

    /**
     * (optional) linked person object for this product. (obsolete, deprecated, use person_list)
     *
     * @var \App\Traits\Person
     */
    private $person;

    /**
     * (optional) list of linked person object for this product.
     *
     * @var \App\Traits\Person[]
     */
    private $person_list;

    /**
     * a list of related orderProduct objects, returned by find_available_price, and indicates related service product types to accommodations
     *
     * @var \App\Traits\OrderProduct[]
     */
    private $related;

    /**
     * (optional) list of external booking references
     *
     * @var \App\Traits\ExternalBookingReference[]
     */
    private $external_booking_references;

    /**
     * (optional) Notes related to the booking
     *
     * @var string
     */
    private $notes;

    /**
     * (optional) gender specification, used for f.ex hostels
     *
     * @var integer
     */
    private $gender;

    /**
     * (optional) guest_type, use 1=Conference and Education, 2=Business, 3=Pleasure/vacation, defaults to 3
     *
     * @var integer
     */
    private $guest_type;

    /**
     * (Optional) List of ages, stores the age(s) on person(s) related to this OrderProduct
     *
     * @var integer[]
     */
    private $ages;

    /**
     * (optional) if booked via event, eventId - id of the event
     *
     * @var integer
     */
    private $event_id;

    /**
     * Constructs a OrderProduct from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * price object, to specify which price is to be used, see price object for description, if price_value is provided, this will override calculated price
     *
     * @return \App\Traits\Price
     */
    public function getPrice()
    {
        return $this->price;
    }

    /**
     * price object, to specify which price is to be used, see price object for description, if price_value is provided, this will override calculated price
     *
     * @param \App\Traits\Price $price
     */
    public function setPrice($price)
    {
        $this->price = $price;
    }
    /**
     * the arrival date/time
     *
     * @return integer
     */
    public function getFrom_date()
    {
        return $this->from_date;
    }

    /**
     * the arrival date/time
     *
     * @param integer $from_date
     */
    public function setFrom_date($from_date)
    {
        $this->from_date = $from_date;
    }
    /**
     * the departure date/time
     *
     * @return integer
     */
    public function getTo_date()
    {
        return $this->to_date;
    }

    /**
     * the departure date/time
     *
     * @param integer $to_date
     */
    public function setTo_date($to_date)
    {
        $this->to_date = $to_date;
    }
    /**
     * number of product units, f. ex. 2 rooms, 3 boats, 1 newspaper
     *
     * @return integer
     */
    public function getUnits()
    {
        return $this->units;
    }

    /**
     * number of product units, f. ex. 2 rooms, 3 boats, 1 newspaper
     *
     * @param integer $units
     */
    public function setUnits($units)
    {
        $this->units = $units;
    }
    /**
     * Total number of persons that is to use the product, f.ex a double room has typically 2 persons.
     *
     * @return integer
     */
    public function getPersons()
    {
        return $this->persons;
    }

    /**
     * Total number of persons that is to use the product, f.ex a double room has typically 2 persons.
     *
     * @param integer $persons
     */
    public function setPersons($persons)
    {
        $this->persons = $persons;
    }
    /**
     * (optional) number of persons in rebate1 category
     *
     * @return integer
     */
    public function getPersons_rebate1()
    {
        return $this->persons_rebate1;
    }

    /**
     * (optional) number of persons in rebate1 category
     *
     * @param integer $persons_rebate1
     */
    public function setPersons_rebate1($persons_rebate1)
    {
        $this->persons_rebate1 = $persons_rebate1;
    }
    /**
     * (optional) number of persons in rebate2 category
     *
     * @return integer
     */
    public function getPersons_rebate2()
    {
        return $this->persons_rebate2;
    }

    /**
     * (optional) number of persons in rebate2 category
     *
     * @param integer $persons_rebate2
     */
    public function setPersons_rebate2($persons_rebate2)
    {
        $this->persons_rebate2 = $persons_rebate2;
    }
    /**
     * unique id (per company) that is non zero if the product is reserved, see reserve_products command
     *
     * @return integer
     */
    public function getReservation_id()
    {
        return $this->reservation_id;
    }

    /**
     * unique id (per company) that is non zero if the product is reserved, see reserve_products command
     *
     * @param integer $reservation_id
     */
    public function setReservation_id($reservation_id)
    {
        $this->reservation_id = $reservation_id;
    }
    /**
     * (optional) String representing the person name who should check in on the object
     *
     * @return string
     */
    public function getPerson_name()
    {
        return $this->person_name;
    }

    /**
     * (optional) String representing the person name who should check in on the object
     *
     * @param string $person_name
     */
    public function setPerson_name($person_name)
    {
        $this->person_name = $person_name;
    }
    /**
     * (optional) linked person object for this product. (obsolete, deprecated, use person_list)
     *
     * @return \App\Traits\Person
     */
    public function getPerson()
    {
        return $this->person;
    }

    /**
     * (optional) linked person object for this product. (obsolete, deprecated, use person_list)
     *
     * @param \App\Traits\Person $person
     */
    public function setPerson($person)
    {
        $this->person = $person;
    }
    /**
     * (optional) list of linked person object for this product.
     *
     * @return \App\Traits\Person[]
     */
    public function getPerson_list()
    {
        return $this->person_list;
    }

    /**
     * (optional) list of linked person object for this product.
     *
     * @param \App\Traits\Person[] $person_list
     */
    public function setPerson_list($person_list)
    {
        $this->person_list = $person_list;
    }
    /**
     * a list of related orderProduct objects, returned by find_available_price, and indicates related service product types to accommodations
     *
     * @return \App\Traits\OrderProduct[]
     */
    public function getRelated()
    {
        return $this->related;
    }

    /**
     * a list of related orderProduct objects, returned by find_available_price, and indicates related service product types to accommodations
     *
     * @param \App\Traits\OrderProduct[] $related
     */
    public function setRelated($related)
    {
        $this->related = $related;
    }
    /**
     * (optional) list of external booking references
     *
     * @return \App\Traits\ExternalBookingReference[]
     */
    public function getExternal_booking_references()
    {
        return $this->external_booking_references;
    }

    /**
     * (optional) list of external booking references
     *
     * @param \App\Traits\ExternalBookingReference[] $external_booking_references
     */
    public function setExternal_booking_references($external_booking_references)
    {
        $this->external_booking_references = $external_booking_references;
    }
    /**
     * (optional) Notes related to the booking
     *
     * @return string
     */
    public function getNotes()
    {
        return $this->notes;
    }

    /**
     * (optional) Notes related to the booking
     *
     * @param string $notes
     */
    public function setNotes($notes)
    {
        $this->notes = $notes;
    }
    /**
     * (optional) gender specification, used for f.ex hostels
     *
     * @return integer
     */
    public function getGender()
    {
        return $this->gender;
    }

    /**
     * (optional) gender specification, used for f.ex hostels
     *
     * @param integer $gender
     */
    public function setGender($gender)
    {
        $this->gender = $gender;
    }
    /**
     * (optional) guest_type, use 1=Conference and Education, 2=Business, 3=Pleasure/vacation, defaults to 3
     *
     * @return integer
     */
    public function getGuest_type()
    {
        return $this->guest_type;
    }

    /**
     * (optional) guest_type, use 1=Conference and Education, 2=Business, 3=Pleasure/vacation, defaults to 3
     *
     * @param integer $guest_type
     */
    public function setGuest_type($guest_type)
    {
        $this->guest_type = $guest_type;
    }
    /**
     * (Optional) List of ages, stores the age(s) on person(s) related to this OrderProduct
     *
     * @return integer[]
     */
    public function getAges()
    {
        return $this->ages;
    }

    /**
     * (Optional) List of ages, stores the age(s) on person(s) related to this OrderProduct
     *
     * @param integer[] $ages
     */
    public function setAges($ages)
    {
        $this->ages = $ages;
    }
    /**
     * (optional) if booked via event, eventId - id of the event
     *
     * @return integer
     */
    public function getEvent_id()
    {
        return $this->event_id;
    }

    /**
     * (optional) if booked via event, eventId - id of the event
     *
     * @param integer $event_id
     */
    public function setEvent_id($event_id)
    {
        $this->event_id = $event_id;
    }

    /**
     * Sets a known child element of OrderProduct from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'price') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\Price($xml);
            $this->price = $child;
            $happened = true;
        }
        else if (($xml->localName == 'from_date') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->from_date = $child;
            $happened = true;
        }
        else if (($xml->localName == 'to_date') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->to_date = $child;
            $happened = true;
        }
        else if (($xml->localName == 'units') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->units = $child;
            $happened = true;
        }
        else if (($xml->localName == 'persons') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->persons = $child;
            $happened = true;
        }
        else if (($xml->localName == 'persons_rebate1') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->persons_rebate1 = $child;
            $happened = true;
        }
        else if (($xml->localName == 'persons_rebate2') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->persons_rebate2 = $child;
            $happened = true;
        }
        else if (($xml->localName == 'reservation_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->reservation_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'person_name') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->person_name = $child;
            $happened = true;
        }
        else if (($xml->localName == 'person') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\Person($xml);
            $this->person = $child;
            $happened = true;
        }
        else if (($xml->localName == 'person_list') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\Person($xml);
            if (!isset($this->person_list)) {
                $this->person_list = array();
            }
            array_push($this->person_list, $child);
            $happened = true;
        }
        else if (($xml->localName == 'related') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\OrderProduct($xml);
            if (!isset($this->related)) {
                $this->related = array();
            }
            array_push($this->related, $child);
            $happened = true;
        }
        else if (($xml->localName == 'external_booking_references') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\ExternalBookingReference($xml);
            if (!isset($this->external_booking_references)) {
                $this->external_booking_references = array();
            }
            array_push($this->external_booking_references, $child);
            $happened = true;
        }
        else if (($xml->localName == 'notes') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->notes = $child;
            $happened = true;
        }
        else if (($xml->localName == 'gender') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->gender = $child;
            $happened = true;
        }
        else if (($xml->localName == 'guest_type') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->guest_type = $child;
            $happened = true;
        }
        else if (($xml->localName == 'ages') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->ages)) {
                $this->ages = array();
            }
            array_push($this->ages, $child);
            $happened = true;
        }
        else if (($xml->localName == 'event_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->event_id = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of OrderProduct from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes the contents of this OrderProduct to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->price) {
            $writer->startElementNs(null, 'price', null);
            $this->price->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->from_date) {
            $writer->startElementNs(null, 'from_date', null);
            $writer->text($this->from_date);
            $writer->endElement();
        }
        if ($this->to_date) {
            $writer->startElementNs(null, 'to_date', null);
            $writer->text($this->to_date);
            $writer->endElement();
        }
        if ($this->units) {
            $writer->startElementNs(null, 'units', null);
            $writer->text($this->units);
            $writer->endElement();
        }
        if ($this->persons) {
            $writer->startElementNs(null, 'persons', null);
            $writer->text($this->persons);
            $writer->endElement();
        }
        if ($this->persons_rebate1) {
            $writer->startElementNs(null, 'persons_rebate1', null);
            $writer->text($this->persons_rebate1);
            $writer->endElement();
        }
        if ($this->persons_rebate2) {
            $writer->startElementNs(null, 'persons_rebate2', null);
            $writer->text($this->persons_rebate2);
            $writer->endElement();
        }
        if ($this->reservation_id) {
            $writer->startElementNs(null, 'reservation_id', null);
            $writer->text($this->reservation_id);
            $writer->endElement();
        }
        if ($this->person_name) {
            $writer->startElementNs(null, 'person_name', null);
            $writer->text($this->person_name);
            $writer->endElement();
        }
        if ($this->person) {
            $writer->startElementNs(null, 'person', null);
            $this->person->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->person_list) {
            foreach ($this->person_list as $i => $x) {
                $writer->startElementNs(null, 'person_list', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->related) {
            foreach ($this->related as $i => $x) {
                $writer->startElementNs(null, 'related', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->external_booking_references) {
            foreach ($this->external_booking_references as $i => $x) {
                $writer->startElementNs(null, 'external_booking_references', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->notes) {
            $writer->startElementNs(null, 'notes', null);
            $writer->text($this->notes);
            $writer->endElement();
        }
        if ($this->gender) {
            $writer->startElementNs(null, 'gender', null);
            $writer->text($this->gender);
            $writer->endElement();
        }
        if ($this->guest_type) {
            $writer->startElementNs(null, 'guest_type', null);
            $writer->text($this->guest_type);
            $writer->endElement();
        }
        if ($this->ages) {
            foreach ($this->ages as $i => $x) {
                $writer->startElementNs(null, 'ages', null);
                $writer->text($x);
                $writer->endElement();
            }
        }
        if ($this->event_id) {
            $writer->startElementNs(null, 'event_id', null);
            $writer->text($this->event_id);
            $writer->endElement();
        }
    }
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class GuestStatus
{

    /**
     * Guest is not arrived
     */
    const NOT_ARRIVED = "not_arrived";

    /**
     * Guest has arrived, and currently is staying in the hotel
     */
    const ARRIVED = "arrived";

    /**
     * The guest has departed from the hotel
     */
    const DEPARTURED = "departured";
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class CreditCardType
{

    /**
     *
     */
    const BANKAXEPT = "BANKAXEPT";

    /**
     *
     */
    const VISA = "VISA";

    /**
     *
     */
    const EUROCARD = "EUROCARD";

    /**
     *
     */
    const AMEX = "AMEX";

    /**
     *
     */
    const DINERS = "DINERS";

    /**
     *
     */
    const UNKNOWN = "UNKNOWN";
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class CustomerType
{

    /**
     * Private person
     */
    const PERSON = "person";

    /**
     * Company type customer
     */
    const COMPANY = "company";

    /**
     * external bookingservice type customer (rarely used)
     */
    const BOOKING = "booking";

    /**
     * master customer that groups several other customers
     */
    const MASTER = "master";
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class AttributeType
{

    /**
     *
     */
    const UNKNOWN = "UNKNOWN";

    /**
     * a true/false type
     */
    const BOOLEAN = "BOOLEAN";

    /**
     * an integer type (1,2,3,4 etc...)
     */
    const NUMERIC = "NUMERIC";

    /**
     * a text type (description)
     */
    const TEXT = "TEXT";

    /**
     * floating point type (1.23, 2.34 etc)
     */
    const FLOAT = "FLOAT";

    /**
     * grouped by text, enum like type
     */
    const TEXTGROUP = "TEXTGROUP";

    /**
     * text encoded with html
     */
    const HTML = "HTML";

    /**
     * date and time
     */
    const DATE = "DATE";

    /**
     * time type
     */
    const TIME = "TIME";
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class ThumbnailType
{

    /**
     * Indicates that this is a full image, not a thumbnail
     */
    const FULL = "FULL";

    /**
     * Medium sized thumbnail
     */
    const MEDIUM = "MEDIUM";

    /**
     * Small size thumbnail
     */
    const SMALL = "SMALL";
}

namespace Com\Visbook\Util;

/**
 * (no documentation provided)
 */
class SysStatus
{

    /**
     * None type
     */
    const NONE = "None";

    /**
     * CreditNote
     */
    const CREDITNOTE = "CreditNote";

    /**
     * PartialInvoice
     */
    const PARTIALINVOICE = "PartialInvoice";

    /**
     * Credited
     */
    const CREDITED = "Credited";

    /**
     * CopiedFromCreditedInvoice
     */
    const COPIEDFROMCREDITEDINVOICE = "CopiedFromCreditedInvoice";

    /**
     * PartialInvoiceAlternative
     */
    const PARTIALINVOICEALTERNATIVE = "PartialInvoiceAlternative";

    /**
     * NoShowRelation
     */
    const NOSHOWRELATION = "NoShowRelation";
}

namespace Com\Visbook\Util;

/**
 * (no documentation provided)
 */
class StatusType
{

    /**
     * The order is in status &quot;offer&quot;
     */
    const OFFER = "offer";

    /**
     * The order is in status ordered
     */
    const ORDERED = "order";

    /**
     * The order has been invoiced
     */
    const INVOICED = "invoiced";

    /**
     * The order has been paid in full (NB; spelling error)
     */
    const PAYED = "payed";

    /**
     * The order has been canceled
     */
    const CANCELLED = "cancelled";
}

namespace App\Traits;

/**
 * (no documentation provided)
 */
class Booking extends \App\Traits\OrderProduct
{

    /**
     * unique booking identification
     *
     * @var integer
     */
    private $booking_id;

    /**
     * indicates the booking status (same as order status)
     *
     * @var string
     */
    private $status;

    /**
     * the date the booking was last changed.
     *
     * @var integer
     */
    private $changed_date;

    /**
     * indicates if a guest has arrived or departured.
     *
     * @var string
     */
    private $guest_status;

    /**
     * the customer id
     *
     * @var integer
     */
    private $customer_id;

    /**
     * (optional) contains the customer object
     *
     * @var \App\Traits\Customer
     */
    private $customer;

    /**
     * optional if not the same as customer_id, set here for the arriving customer
     *
     * @var integer
     */
    private $arrival_customer_id;

    /**
     * optional, contains the arrival customer object
     *
     * @var \App\Traits\Customer
     */
    private $arrival_customer;

    /**
     * optional other customer id attached to this booking.
     *
     * @var integer
     */
    private $other_customer_id;

    /**
     * optional, other customer object attached to this booking.
     *
     * @var \App\Traits\Customer
     */
    private $other_customer;

    /**
     * set on check_in for use on keycard systems
     *
     * @var integer
     */
    private $keycard_id;

    /**
     * id related to which order this booking belongs to
     *
     * @var integer
     */
    private $order_id;

    /**
     * if non zero, related to some other booking in same order
     *
     * @var integer
     */
    private $master_booking_id;

    /**
     * the amount for this product/booking
     *
     * @var double
     */
    private $amount;

    /**
     * list of VAT Information
     *
     * @var \App\Traits\VATInfo[]
     */
    private $vat_list;

    /**
     * UID
     *
     * @var integer
     */
    private $owner_id;

    /**
     * last changed by id
     *
     * @var integer
     */
    private $changed_id;

    /**
     * Checkout payment rule
     *
     * @var integer
     */
    private $checkout_payment_rule;

    /**
     * checkout payment rule note
     *
     * @var string
     */
    private $checkout_payment_rule_note;

    /**
     * Timestamp when the booking was registered
     *
     * @var integer
     */
    private $registration_date;

    /**
     * Constructs a Booking from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * unique booking identification
     *
     * @return integer
     */
    public function getBooking_id()
    {
        return $this->booking_id;
    }

    /**
     * unique booking identification
     *
     * @param integer $booking_id
     */
    public function setBooking_id($booking_id)
    {
        $this->booking_id = $booking_id;
    }
    /**
     * indicates the booking status (same as order status)
     *
     * @return string
     */
    public function getStatus()
    {
        return $this->status;
    }

    /**
     * indicates the booking status (same as order status)
     *
     * @param string $status
     */
    public function setStatus($status)
    {
        $this->status = $status;
    }
    /**
     * the date the booking was last changed.
     *
     * @return integer
     */
    public function getChanged_date()
    {
        return $this->changed_date;
    }

    /**
     * the date the booking was last changed.
     *
     * @param integer $changed_date
     */
    public function setChanged_date($changed_date)
    {
        $this->changed_date = $changed_date;
    }
    /**
     * indicates if a guest has arrived or departured.
     *
     * @return string
     */
    public function getGuest_status()
    {
        return $this->guest_status;
    }

    /**
     * indicates if a guest has arrived or departured.
     *
     * @param string $guest_status
     */
    public function setGuest_status($guest_status)
    {
        $this->guest_status = $guest_status;
    }
    /**
     * the customer id
     *
     * @return integer
     */
    public function getCustomer_id()
    {
        return $this->customer_id;
    }

    /**
     * the customer id
     *
     * @param integer $customer_id
     */
    public function setCustomer_id($customer_id)
    {
        $this->customer_id = $customer_id;
    }
    /**
     * (optional) contains the customer object
     *
     * @return \App\Traits\Customer
     */
    public function getCustomer()
    {
        return $this->customer;
    }

    /**
     * (optional) contains the customer object
     *
     * @param \App\Traits\Customer $customer
     */
    public function setCustomer($customer)
    {
        $this->customer = $customer;
    }
    /**
     * optional if not the same as customer_id, set here for the arriving customer
     *
     * @return integer
     */
    public function getArrival_customer_id()
    {
        return $this->arrival_customer_id;
    }

    /**
     * optional if not the same as customer_id, set here for the arriving customer
     *
     * @param integer $arrival_customer_id
     */
    public function setArrival_customer_id($arrival_customer_id)
    {
        $this->arrival_customer_id = $arrival_customer_id;
    }
    /**
     * optional, contains the arrival customer object
     *
     * @return \App\Traits\Customer
     */
    public function getArrival_customer()
    {
        return $this->arrival_customer;
    }

    /**
     * optional, contains the arrival customer object
     *
     * @param \App\Traits\Customer $arrival_customer
     */
    public function setArrival_customer($arrival_customer)
    {
        $this->arrival_customer = $arrival_customer;
    }
    /**
     * optional other customer id attached to this booking.
     *
     * @return integer
     */
    public function getOther_customer_id()
    {
        return $this->other_customer_id;
    }

    /**
     * optional other customer id attached to this booking.
     *
     * @param integer $other_customer_id
     */
    public function setOther_customer_id($other_customer_id)
    {
        $this->other_customer_id = $other_customer_id;
    }
    /**
     * optional, other customer object attached to this booking.
     *
     * @return \App\Traits\Customer
     */
    public function getOther_customer()
    {
        return $this->other_customer;
    }

    /**
     * optional, other customer object attached to this booking.
     *
     * @param \App\Traits\Customer $other_customer
     */
    public function setOther_customer($other_customer)
    {
        $this->other_customer = $other_customer;
    }
    /**
     * set on check_in for use on keycard systems
     *
     * @return integer
     */
    public function getKeycard_id()
    {
        return $this->keycard_id;
    }

    /**
     * set on check_in for use on keycard systems
     *
     * @param integer $keycard_id
     */
    public function setKeycard_id($keycard_id)
    {
        $this->keycard_id = $keycard_id;
    }
    /**
     * id related to which order this booking belongs to
     *
     * @return integer
     */
    public function getOrder_id()
    {
        return $this->order_id;
    }

    /**
     * id related to which order this booking belongs to
     *
     * @param integer $order_id
     */
    public function setOrder_id($order_id)
    {
        $this->order_id = $order_id;
    }
    /**
     * if non zero, related to some other booking in same order
     *
     * @return integer
     */
    public function getMaster_booking_id()
    {
        return $this->master_booking_id;
    }

    /**
     * if non zero, related to some other booking in same order
     *
     * @param integer $master_booking_id
     */
    public function setMaster_booking_id($master_booking_id)
    {
        $this->master_booking_id = $master_booking_id;
    }
    /**
     * the amount for this product/booking
     *
     * @return double
     */
    public function getAmount()
    {
        return $this->amount;
    }

    /**
     * the amount for this product/booking
     *
     * @param double $amount
     */
    public function setAmount($amount)
    {
        $this->amount = $amount;
    }
    /**
     * list of VAT Information
     *
     * @return \App\Traits\VATInfo[]
     */
    public function getVat_list()
    {
        return $this->vat_list;
    }

    /**
     * list of VAT Information
     *
     * @param \App\Traits\VATInfo[] $vat_list
     */
    public function setVat_list($vat_list)
    {
        $this->vat_list = $vat_list;
    }
    /**
     * UID
     *
     * @return integer
     */
    public function getOwner_id()
    {
        return $this->owner_id;
    }

    /**
     * UID
     *
     * @param integer $owner_id
     */
    public function setOwner_id($owner_id)
    {
        $this->owner_id = $owner_id;
    }
    /**
     * last changed by id
     *
     * @return integer
     */
    public function getChanged_id()
    {
        return $this->changed_id;
    }

    /**
     * last changed by id
     *
     * @param integer $changed_id
     */
    public function setChanged_id($changed_id)
    {
        $this->changed_id = $changed_id;
    }
    /**
     * Checkout payment rule
     *
     * @return integer
     */
    public function getCheckout_payment_rule()
    {
        return $this->checkout_payment_rule;
    }

    /**
     * Checkout payment rule
     *
     * @param integer $checkout_payment_rule
     */
    public function setCheckout_payment_rule($checkout_payment_rule)
    {
        $this->checkout_payment_rule = $checkout_payment_rule;
    }
    /**
     * checkout payment rule note
     *
     * @return string
     */
    public function getCheckout_payment_rule_note()
    {
        return $this->checkout_payment_rule_note;
    }

    /**
     * checkout payment rule note
     *
     * @param string $checkout_payment_rule_note
     */
    public function setCheckout_payment_rule_note($checkout_payment_rule_note)
    {
        $this->checkout_payment_rule_note = $checkout_payment_rule_note;
    }
    /**
     * Timestamp when the booking was registered
     *
     * @return integer
     */
    public function getRegistration_date()
    {
        return $this->registration_date;
    }

    /**
     * Timestamp when the booking was registered
     *
     * @param integer $registration_date
     */
    public function setRegistration_date($registration_date)
    {
        $this->registration_date = $registration_date;
    }

    /**
     * Sets a known child element of Booking from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'booking_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->booking_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'status') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->status = $child;
            $happened = true;
        }
        else if (($xml->localName == 'changed_date') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->changed_date = $child;
            $happened = true;
        }
        else if (($xml->localName == 'guest_status') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->guest_status = $child;
            $happened = true;
        }
        else if (($xml->localName == 'customer_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->customer_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'customer') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\Customer($xml);
            $this->customer = $child;
            $happened = true;
        }
        else if (($xml->localName == 'arrival_customer_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->arrival_customer_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'arrival_customer') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\Customer($xml);
            $this->arrival_customer = $child;
            $happened = true;
        }
        else if (($xml->localName == 'other_customer_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->other_customer_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'other_customer') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\Customer($xml);
            $this->other_customer = $child;
            $happened = true;
        }
        else if (($xml->localName == 'keycard_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->keycard_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'order_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->order_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'master_booking_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->master_booking_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'amount') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->amount = $child;
            $happened = true;
        }
        else if (($xml->localName == 'vat_list') && (empty($xml->namespaceURI))) {
            $child = new \App\Traits\VATInfo($xml);
            if (!isset($this->vat_list)) {
                $this->vat_list = array();
            }
            array_push($this->vat_list, $child);
            $happened = true;
        }
        else if (($xml->localName == 'owner_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->owner_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'changed_id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->changed_id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'checkout_payment_rule') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->checkout_payment_rule = $child;
            $happened = true;
        }
        else if (($xml->localName == 'checkout_payment_rule_note') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->checkout_payment_rule_note = $child;
            $happened = true;
        }
        else if (($xml->localName == 'registration_date') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->registration_date = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of Booking from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes the contents of this Booking to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->booking_id) {
            $writer->startElementNs(null, 'booking_id', null);
            $writer->text($this->booking_id);
            $writer->endElement();
        }
        if ($this->status) {
            $writer->startElementNs(null, 'status', null);
            $writer->text($this->status);
            $writer->endElement();
        }
        if ($this->changed_date) {
            $writer->startElementNs(null, 'changed_date', null);
            $writer->text($this->changed_date);
            $writer->endElement();
        }
        if ($this->guest_status) {
            $writer->startElementNs(null, 'guest_status', null);
            $writer->text($this->guest_status);
            $writer->endElement();
        }
        if ($this->customer_id) {
            $writer->startElementNs(null, 'customer_id', null);
            $writer->text($this->customer_id);
            $writer->endElement();
        }
        if ($this->customer) {
            $writer->startElementNs(null, 'customer', null);
            $this->customer->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->arrival_customer_id) {
            $writer->startElementNs(null, 'arrival_customer_id', null);
            $writer->text($this->arrival_customer_id);
            $writer->endElement();
        }
        if ($this->arrival_customer) {
            $writer->startElementNs(null, 'arrival_customer', null);
            $this->arrival_customer->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->other_customer_id) {
            $writer->startElementNs(null, 'other_customer_id', null);
            $writer->text($this->other_customer_id);
            $writer->endElement();
        }
        if ($this->other_customer) {
            $writer->startElementNs(null, 'other_customer', null);
            $this->other_customer->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->keycard_id) {
            $writer->startElementNs(null, 'keycard_id', null);
            $writer->text($this->keycard_id);
            $writer->endElement();
        }
        if ($this->order_id) {
            $writer->startElementNs(null, 'order_id', null);
            $writer->text($this->order_id);
            $writer->endElement();
        }
        if ($this->master_booking_id) {
            $writer->startElementNs(null, 'master_booking_id', null);
            $writer->text($this->master_booking_id);
            $writer->endElement();
        }
        if ($this->amount) {
            $writer->startElementNs(null, 'amount', null);
            $writer->text($this->amount);
            $writer->endElement();
        }
        if ($this->vat_list) {
            foreach ($this->vat_list as $i => $x) {
                $writer->startElementNs(null, 'vat_list', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->owner_id) {
            $writer->startElementNs(null, 'owner_id', null);
            $writer->text($this->owner_id);
            $writer->endElement();
        }
        if ($this->changed_id) {
            $writer->startElementNs(null, 'changed_id', null);
            $writer->text($this->changed_id);
            $writer->endElement();
        }
        if ($this->checkout_payment_rule) {
            $writer->startElementNs(null, 'checkout_payment_rule', null);
            $writer->text($this->checkout_payment_rule);
            $writer->endElement();
        }
        if ($this->checkout_payment_rule_note) {
            $writer->startElementNs(null, 'checkout_payment_rule_note', null);
            $writer->text($this->checkout_payment_rule_note);
            $writer->endElement();
        }
        if ($this->registration_date) {
            $writer->startElementNs(null, 'registration_date', null);
            $writer->text($this->registration_date);
            $writer->endElement();
        }
    }
}
